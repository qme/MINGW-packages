diff -Naur gcc-8.2.0/gcc/ada/libgnarl/s-osinte__solaris.ads gcc-8-20181012/gcc/ada/libgnarl/s-osinte__solaris.ads
--- gcc-8.2.0/gcc/ada/libgnarl/s-osinte__solaris.ads	2018-01-11 11:55:25.000000000 +0300
+++ gcc-8-20181012/gcc/ada/libgnarl/s-osinte__solaris.ads	2018-09-13 13:13:15.000000000 +0300
@@ -536,17 +536,18 @@
    end record;
    pragma Convention (C, record_type_3);
 
+   type upad64_t is new Interfaces.Unsigned_64;
+
    type mutex_t is record
       flags : record_type_3;
-      lock  : String (1 .. 8);
-      data  : String (1 .. 8);
+      lock  : upad64_t;
+      data  : upad64_t;
    end record;
    pragma Convention (C, mutex_t);
 
    type cond_t is record
-      flag  : array_type_9;
-      Xtype : unsigned_long;
-      data  : String (1 .. 8);
+      flags : record_type_3;
+      data  : upad64_t;
    end record;
    pragma Convention (C, cond_t);
 
diff -Naur gcc-8.2.0/gcc/asan.c gcc-8-20181012/gcc/asan.c
--- gcc-8.2.0/gcc/asan.c	2018-04-17 23:22:50.000000000 +0300
+++ gcc-8-20181012/gcc/asan.c	2018-09-25 09:50:30.000000000 +0300
@@ -253,7 +253,7 @@
 /* Set of variable declarations that are going to be guarded by
    use-after-scope sanitizer.  */
 
-static hash_set<tree> *asan_handled_variables = NULL;
+hash_set<tree> *asan_handled_variables = NULL;
 
 hash_set <tree> *asan_used_labels = NULL;
 
diff -Naur gcc-8.2.0/gcc/asan.h gcc-8-20181012/gcc/asan.h
--- gcc-8.2.0/gcc/asan.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/asan.h	2018-09-25 09:50:30.000000000 +0300
@@ -110,6 +110,8 @@
 
 extern bool asan_sanitize_allocas_p (void);
 
+extern hash_set<tree> *asan_handled_variables;
+
 /* Return TRUE if builtin with given FCODE will be intercepted by
    libasan.  */
 
diff -Naur gcc-8.2.0/gcc/c/c-typeck.c gcc-8-20181012/gcc/c/c-typeck.c
--- gcc-8.2.0/gcc/c/c-typeck.c	2018-06-20 23:40:33.000000000 +0300
+++ gcc-8-20181012/gcc/c/c-typeck.c	2018-08-01 12:35:34.000000000 +0300
@@ -9316,6 +9316,65 @@
     output_pending_init_elements (0, braced_init_obstack);
 }
 
+/* For two FIELD_DECLs in the same chain, return -1 if field1
+   comes before field2, 1 if field1 comes after field2 and
+   0 if field1 == field2.  */
+
+static int
+init_field_decl_cmp (tree field1, tree field2)
+{
+  if (field1 == field2)
+    return 0;
+
+  tree bitpos1 = bit_position (field1);
+  tree bitpos2 = bit_position (field2);
+  if (tree_int_cst_equal (bitpos1, bitpos2))
+    {
+      /* If one of the fields has non-zero bitsize, then that
+	 field must be the last one in a sequence of zero
+	 sized fields, fields after it will have bigger
+	 bit_position.  */
+      if (TREE_TYPE (field1) != error_mark_node
+	  && COMPLETE_TYPE_P (TREE_TYPE (field1))
+	  && integer_nonzerop (TREE_TYPE (field1)))
+	return 1;
+      if (TREE_TYPE (field2) != error_mark_node
+	  && COMPLETE_TYPE_P (TREE_TYPE (field2))
+	  && integer_nonzerop (TREE_TYPE (field2)))
+	return -1;
+      /* Otherwise, fallback to DECL_CHAIN walk to find out
+	 which field comes earlier.  Walk chains of both
+	 fields, so that if field1 and field2 are close to each
+	 other in either order, it is found soon even for large
+	 sequences of zero sized fields.  */
+      tree f1 = field1, f2 = field2;
+      while (1)
+	{
+	  f1 = DECL_CHAIN (f1);
+	  f2 = DECL_CHAIN (f2);
+	  if (f1 == NULL_TREE)
+	    {
+	      gcc_assert (f2);
+	      return 1;
+	    }
+	  if (f2 == NULL_TREE)
+	    return -1;
+	  if (f1 == field2)
+	    return -1;
+	  if (f2 == field1)
+	    return 1;
+	  if (!tree_int_cst_equal (bit_position (f1), bitpos1))
+	    return 1;
+	  if (!tree_int_cst_equal (bit_position (f2), bitpos1))
+	    return -1;
+	}
+    }
+  else if (tree_int_cst_lt (bitpos1, bitpos2))
+    return -1;
+  else
+    return 1;
+}
+
 /* Output any pending elements which have become next.
    As we output elements, constructor_unfilled_{fields,index}
    advances, which may cause other elements to become next;
@@ -9387,25 +9446,18 @@
 	}
       else if (RECORD_OR_UNION_TYPE_P (constructor_type))
 	{
-	  tree ctor_unfilled_bitpos, elt_bitpos;
-
 	  /* If the current record is complete we are done.  */
 	  if (constructor_unfilled_fields == NULL_TREE)
 	    break;
 
-	  ctor_unfilled_bitpos = bit_position (constructor_unfilled_fields);
-	  elt_bitpos = bit_position (elt->purpose);
-	  /* We can't compare fields here because there might be empty
-	     fields in between.  */
-	  if (tree_int_cst_equal (elt_bitpos, ctor_unfilled_bitpos))
-	    {
-	      constructor_unfilled_fields = elt->purpose;
-	      output_init_element (input_location, elt->value, elt->origtype,
-				   true, TREE_TYPE (elt->purpose),
-				   elt->purpose, false, false,
-				   braced_init_obstack);
-	    }
-	  else if (tree_int_cst_lt (ctor_unfilled_bitpos, elt_bitpos))
+	  int cmp = init_field_decl_cmp (constructor_unfilled_fields,
+					 elt->purpose);
+	  if (cmp == 0)
+	    output_init_element (input_location, elt->value, elt->origtype,
+				 true, TREE_TYPE (elt->purpose),
+				 elt->purpose, false, false,
+				 braced_init_obstack);
+	  else if (cmp < 0)
 	    {
 	      /* Advance to the next smaller node.  */
 	      if (elt->left)
@@ -9431,8 +9483,8 @@
 		    elt = elt->parent;
 		  elt = elt->parent;
 		  if (elt
-		      && (tree_int_cst_lt (ctor_unfilled_bitpos,
-					   bit_position (elt->purpose))))
+		      && init_field_decl_cmp (constructor_unfilled_fields,
+					      elt->purpose) < 0)
 		    {
 		      next = elt->purpose;
 		      break;
diff -Naur gcc-8.2.0/gcc/calls.c gcc-8-20181012/gcc/calls.c
--- gcc-8.2.0/gcc/calls.c	2018-07-18 20:20:05.000000000 +0300
+++ gcc-8-20181012/gcc/calls.c	2018-08-28 14:43:22.000000000 +0300
@@ -1627,6 +1627,9 @@
   if (!fndecl || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)
     return;
 
+  if (!warn_stringop_overflow)
+    return;
+
   bool with_bounds = CALL_WITH_BOUNDS_P (exp);
 
   unsigned nargs = call_expr_nargs (exp);
@@ -1655,7 +1658,10 @@
 	   conservatively as the bound for the unbounded function,
 	   and to adjust the range of the bound of the bounded ones.  */
 	unsigned stride = with_bounds ? 2 : 1;
-	for (unsigned argno = 0; argno < nargs && !*lenrng; argno += stride)
+	for (unsigned argno = 0;
+	     argno < MIN (nargs, 2 * stride)
+	     && !(lenrng[1] && TREE_CODE (lenrng[1]) == INTEGER_CST);
+	     argno += stride)
 	  {
 	    tree arg = CALL_EXPR_ARG (exp, argno);
 	    if (!get_attr_nonstring_decl (arg))
@@ -1693,11 +1699,9 @@
   if (bound)
     get_size_range (bound, bndrng);
 
-  if (*lenrng)
+  if (lenrng[1] && TREE_CODE (lenrng[1]) == INTEGER_CST)
     {
       /* Add one for the nul.  */
-      lenrng[0] = const_binop (PLUS_EXPR, TREE_TYPE (lenrng[0]),
-			       lenrng[0], size_one_node);
       lenrng[1] = const_binop (PLUS_EXPR, TREE_TYPE (lenrng[1]),
 			       lenrng[1], size_one_node);
 
diff -Naur gcc-8.2.0/gcc/c-family/c.opt gcc-8-20181012/gcc/c-family/c.opt
--- gcc-8.2.0/gcc/c-family/c.opt	2018-02-28 01:28:21.000000000 +0300
+++ gcc-8-20181012/gcc/c-family/c.opt	2018-08-17 14:33:25.000000000 +0300
@@ -1339,8 +1339,8 @@
 static-libmpxwrappers
 Driver
 
-fcilkplus Undocumented
-C ObjC C++ ObjC++ LTO Report Var(flag_cilkplus) Init(0)
+fcilkplus
+C ObjC C++ ObjC++ LTO Report Var(flag_cilkplus) Init(0) Undocumented
 Deprecated in GCC 8.  This switch has no effect.
 
 fconcepts
diff -Naur gcc-8.2.0/gcc/cfgexpand.c gcc-8-20181012/gcc/cfgexpand.c
--- gcc-8.2.0/gcc/cfgexpand.c	2018-05-07 00:52:25.000000000 +0300
+++ gcc-8-20181012/gcc/cfgexpand.c	2018-09-25 09:50:30.000000000 +0300
@@ -1157,6 +1157,20 @@
 	      if (repr_decl == NULL_TREE)
 		repr_decl = stack_vars[i].decl;
 	      data->asan_decl_vec.safe_push (repr_decl);
+
+	      /* Make sure a representative is unpoison if another
+		 variable in the partition is handled by
+		 use-after-scope sanitization.  */
+	      if (asan_handled_variables != NULL
+		  && !asan_handled_variables->contains (repr_decl))
+		{
+		  for (j = i; j != EOC; j = stack_vars[j].next)
+		    if (asan_handled_variables->contains (stack_vars[j].decl))
+		      break;
+		  if (j != EOC)
+		    asan_handled_variables->add (repr_decl);
+		}
+
 	      data->asan_alignb = MAX (data->asan_alignb, alignb);
 	      if (data->asan_base == NULL)
 		data->asan_base = gen_reg_rtx (Pmode);
@@ -1259,10 +1273,10 @@
 	 allocate it, which means that in-frame portion is just a
 	 pointer.  ??? We've got a pseudo for sure here, do we
 	 actually dynamically allocate its spilling area if needed?
-	 ??? Isn't it a problem when POINTER_SIZE also exceeds
-	 MAX_SUPPORTED_STACK_ALIGNMENT, as on cris and lm32?  */
+	 ??? Isn't it a problem when Pmode alignment also exceeds
+	 MAX_SUPPORTED_STACK_ALIGNMENT, as can happen on cris and lm32?  */
       if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-	align = POINTER_SIZE;
+	align = GET_MODE_ALIGNMENT (Pmode);
 
       record_alignment_for_reg_var (align);
     }
@@ -1383,7 +1397,7 @@
   /* If the variable alignment is very large we'll dynamicaly allocate
      it, which means that in-frame portion is just a pointer.  */
   if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-    align = POINTER_SIZE;
+    align = GET_MODE_ALIGNMENT (Pmode);
 
   record_alignment_for_reg_var (align);
 
@@ -1610,7 +1624,7 @@
       /* If the variable alignment is very large we'll dynamicaly allocate
 	 it, which means that in-frame portion is just a pointer.  */
       if (align > MAX_SUPPORTED_STACK_ALIGNMENT)
-	align = POINTER_SIZE;
+	align = GET_MODE_ALIGNMENT (Pmode);
     }
 
   record_alignment_for_reg_var (align);
diff -Naur gcc-8.2.0/gcc/combine.c gcc-8-20181012/gcc/combine.c
--- gcc-8.2.0/gcc/combine.c	2018-04-10 18:31:57.000000000 +0300
+++ gcc-8-20181012/gcc/combine.c	2018-09-12 19:23:01.000000000 +0300
@@ -4007,7 +4007,10 @@
      other insns to combine, but the destination of that SET is still live.
 
      Also do this if we started with two insns and (at least) one of the
-     resulting sets is a noop; this noop will be deleted later.  */
+     resulting sets is a noop; this noop will be deleted later.
+
+     Also do this if we started with two insns neither of which was a simple
+     move.  */
 
   else if (insn_code_number < 0 && asm_noperands (newpat) < 0
 	   && GET_CODE (newpat) == PARALLEL
@@ -4035,13 +4038,15 @@
 	 one which uses any regs/memory set in between i2 and i3 can't
 	 be first.  The PARALLEL might also have been pre-existing in i3,
 	 so we need to make sure that we won't wrongly hoist a SET to i2
-	 that would conflict with a death note present in there.  */
+	 that would conflict with a death note present in there, or would
+	 have its dest modified between i2 and i3.  */
       if (!modified_between_p (SET_SRC (set1), i2, i3)
 	  && !(REG_P (SET_DEST (set1))
 	       && find_reg_note (i2, REG_DEAD, SET_DEST (set1)))
 	  && !(GET_CODE (SET_DEST (set1)) == SUBREG
 	       && find_reg_note (i2, REG_DEAD,
 				 SUBREG_REG (SET_DEST (set1))))
+	  && !modified_between_p (SET_DEST (set1), i2, i3)
 	  && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set0))
 	  /* If I3 is a jump, ensure that set0 is a jump so that
 	     we do not create invalid RTL.  */
@@ -4057,6 +4062,7 @@
 	       && !(GET_CODE (SET_DEST (set0)) == SUBREG
 		    && find_reg_note (i2, REG_DEAD,
 				      SUBREG_REG (SET_DEST (set0))))
+	       && !modified_between_p (SET_DEST (set0), i2, i3)
 	       && (!HAVE_cc0 || !reg_referenced_p (cc0_rtx, set1))
 	       /* If I3 is a jump, ensure that set1 is a jump so that
 		  we do not create invalid RTL.  */
@@ -6455,7 +6461,7 @@
 			  pc_rtx, pc_rtx, 0, 0, 0);
       if (reg_mentioned_p (from, false_rtx))
 	false_rtx = subst (known_cond (copy_rtx (false_rtx), false_code,
-				   from, false_val),
+				       from, false_val),
 			   pc_rtx, pc_rtx, 0, 0, 0);
 
       SUBST (XEXP (x, 1), swapped ? false_rtx : true_rtx);
@@ -9294,6 +9300,7 @@
 
 	  if (COMPARISON_P (cond0)
 	      && COMPARISON_P (cond1)
+	      && SCALAR_INT_MODE_P (mode)
 	      && ((GET_CODE (cond0) == reversed_comparison_code (cond1, NULL)
 		   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))
 		   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))
@@ -9474,12 +9481,12 @@
 	  if (COMPARISON_P (x))
 	    {
 	      if (comparison_dominates_p (cond, code))
-		return const_true_rtx;
+		return VECTOR_MODE_P (GET_MODE (x)) ? x : const_true_rtx;
 
 	      code = reversed_comparison_code (x, NULL);
 	      if (code != UNKNOWN
 		  && comparison_dominates_p (cond, code))
-		return const0_rtx;
+		return CONST0_RTX (GET_MODE (x));
 	      else
 		return x;
 	    }
@@ -9522,7 +9529,7 @@
 	  /* We must simplify subreg here, before we lose track of the
 	     original inner_mode.  */
 	  new_rtx = simplify_subreg (GET_MODE (x), r,
-				 inner_mode, SUBREG_BYTE (x));
+				     inner_mode, SUBREG_BYTE (x));
 	  if (new_rtx)
 	    return new_rtx;
 	  else
@@ -9547,7 +9554,7 @@
 	  /* We must simplify the zero_extend here, before we lose
 	     track of the original inner_mode.  */
 	  new_rtx = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
-					  r, inner_mode);
+					      r, inner_mode);
 	  if (new_rtx)
 	    return new_rtx;
 	  else
diff -Naur gcc-8.2.0/gcc/common/config/i386/i386-common.c gcc-8-20181012/gcc/common/config/i386/i386-common.c
--- gcc-8.2.0/gcc/common/config/i386/i386-common.c	2018-04-24 19:56:04.000000000 +0300
+++ gcc-8-20181012/gcc/common/config/i386/i386-common.c	2018-09-05 10:23:45.000000000 +0300
@@ -59,7 +59,7 @@
 #define OPTION_MASK_ISA_FXSR_SET OPTION_MASK_ISA_FXSR
 #define OPTION_MASK_ISA_XSAVE_SET OPTION_MASK_ISA_XSAVE
 #define OPTION_MASK_ISA_XSAVEOPT_SET \
-  (OPTION_MASK_ISA_XSAVEOPT | OPTION_MASK_ISA_XSAVE)
+  (OPTION_MASK_ISA_XSAVEOPT | OPTION_MASK_ISA_XSAVE_SET)
 #define OPTION_MASK_ISA_AVX512F_SET \
   (OPTION_MASK_ISA_AVX512F | OPTION_MASK_ISA_AVX2_SET)
 #define OPTION_MASK_ISA_AVX512CD_SET \
@@ -95,9 +95,9 @@
 #define OPTION_MASK_ISA_PREFETCHWT1_SET OPTION_MASK_ISA_PREFETCHWT1
 #define OPTION_MASK_ISA_CLFLUSHOPT_SET OPTION_MASK_ISA_CLFLUSHOPT
 #define OPTION_MASK_ISA_XSAVES_SET \
-  (OPTION_MASK_ISA_XSAVES | OPTION_MASK_ISA_XSAVE)
+  (OPTION_MASK_ISA_XSAVES | OPTION_MASK_ISA_XSAVE_SET)
 #define OPTION_MASK_ISA_XSAVEC_SET \
-  (OPTION_MASK_ISA_XSAVEC | OPTION_MASK_ISA_XSAVE)
+  (OPTION_MASK_ISA_XSAVEC | OPTION_MASK_ISA_XSAVE_SET)
 #define OPTION_MASK_ISA_CLWB_SET OPTION_MASK_ISA_CLWB
 
 /* SSE4 includes both SSE4.1 and SSE4.2. -msse4 should be the same
@@ -183,7 +183,8 @@
 #define OPTION_MASK_ISA_FMA_UNSET OPTION_MASK_ISA_FMA
 #define OPTION_MASK_ISA_FXSR_UNSET OPTION_MASK_ISA_FXSR
 #define OPTION_MASK_ISA_XSAVE_UNSET \
-  (OPTION_MASK_ISA_XSAVE | OPTION_MASK_ISA_XSAVEOPT_UNSET)
+  (OPTION_MASK_ISA_XSAVE | OPTION_MASK_ISA_XSAVEOPT_UNSET \
+   | OPTION_MASK_ISA_XSAVES_UNSET | OPTION_MASK_ISA_XSAVEC_UNSET)
 #define OPTION_MASK_ISA_XSAVEOPT_UNSET OPTION_MASK_ISA_XSAVEOPT
 #define OPTION_MASK_ISA_AVX2_UNSET \
   (OPTION_MASK_ISA_AVX2 | OPTION_MASK_ISA_AVX512F_UNSET)
diff -Naur gcc-8.2.0/gcc/config/aarch64/aarch64.c gcc-8-20181012/gcc/config/aarch64/aarch64.c
--- gcc-8.2.0/gcc/config/aarch64/aarch64.c	2018-07-04 23:05:23.000000000 +0300
+++ gcc-8-20181012/gcc/config/aarch64/aarch64.c	2018-09-25 03:19:27.000000000 +0300
@@ -325,7 +325,7 @@
   1, /* pre_modify  */
   1, /* post_modify  */
   3, /* register_offset  */
-  4, /* register_sextend  */
+  3, /* register_sextend  */
   3, /* register_zextend  */
   2, /* imm_offset  */
 };
@@ -426,6 +426,26 @@
   1 /* cond_not_taken_branch_cost  */
 };
 
+/* QDF24XX costs for vector insn classes.  */
+static const struct cpu_vector_cost qdf24xx_vector_cost =
+{
+  1, /* scalar_int_stmt_cost  */
+  1, /* scalar_fp_stmt_cost  */
+  1, /* scalar_load_cost  */
+  1, /* scalar_store_cost  */
+  1, /* vec_int_stmt_cost  */
+  3, /* vec_fp_stmt_cost  */
+  2, /* vec_permute_cost  */
+  1, /* vec_to_scalar_cost  */
+  1, /* scalar_to_vec_cost  */
+  1, /* vec_align_load_cost  */
+  1, /* vec_unalign_load_cost  */
+  1, /* vec_unalign_store_cost  */
+  1, /* vec_store_cost  */
+  3, /* cond_taken_branch_cost  */
+  1 /* cond_not_taken_branch_cost  */
+};
+
 /* ThunderX costs for vector insn classes.  */
 static const struct cpu_vector_cost thunderx_vector_cost =
 {
@@ -874,7 +894,7 @@
   &qdf24xx_extra_costs,
   &qdf24xx_addrcost_table,
   &qdf24xx_regmove_cost,
-  &generic_vector_cost,
+  &qdf24xx_vector_cost,
   &generic_branch_cost,
   &generic_approx_modes,
   4, /* memmov_cost  */
@@ -16498,8 +16518,6 @@
   if (aarch64_fusion_enabled_p (AARCH64_FUSE_CMP_BRANCH)
       && any_condjump_p (curr))
     {
-      enum attr_type prev_type = get_attr_type (prev);
-
       unsigned int condreg1, condreg2;
       rtx cc_reg_1;
       aarch64_fixed_condition_code_regs (&condreg1, &condreg2);
@@ -16509,6 +16527,8 @@
 	  && prev
 	  && modified_in_p (cc_reg_1, prev))
 	{
+	  enum attr_type prev_type = get_attr_type (prev);
+
 	  /* FIXME: this misses some which is considered simple arthematic
 	     instructions for ThunderX.  Simple shifts are missed here.  */
 	  if (prev_type == TYPE_ALUS_SREG
diff -Naur gcc-8.2.0/gcc/config/aarch64/falkor.md gcc-8-20181012/gcc/config/aarch64/falkor.md
--- gcc-8.2.0/gcc/config/aarch64/falkor.md	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/aarch64/falkor.md	2018-08-14 17:33:20.000000000 +0300
@@ -322,6 +322,12 @@
        (eq_attr "type" "neon_from_gp_q"))
   "falkor_gtov,falkor_gtov")
 
+;; DUP  does not use vector pipes in Q mode, only gtov+gtov.
+(define_insn_reservation "falkor_am_1_gtov_gtov" 1
+  (and (eq_attr "tune" "falkor")
+       (eq_attr "type" "neon_dup_q"))
+  "falkor_gtov*2")
+
 ;; neon_to_gp_q is used for 32-bit ARM instructions that move 64-bits of data
 ;; so no use needed here.
 
@@ -337,7 +343,7 @@
 
 (define_insn_reservation "falkor_am_1_vxvy_vxvy" 1
   (and (eq_attr "tune" "falkor")
-       (eq_attr "type" "neon_bsl_q,neon_dup_q,neon_ext_q,neon_move_q,neon_rev_q,neon_tbl1_q,neon_permute_q"))
+       (eq_attr "type" "neon_bsl_q,neon_ext_q,neon_move_q,neon_rev_q,neon_tbl1_q,neon_permute_q"))
   "falkor_vxvy+falkor_vxvy")
 
 (define_insn_reservation "falkor_am_2_vxvy" 2
diff -Naur gcc-8.2.0/gcc/config/arm/arm.c gcc-8-20181012/gcc/config/arm/arm.c
--- gcc-8.2.0/gcc/config/arm/arm.c	2018-03-27 17:06:20.000000000 +0300
+++ gcc-8-20181012/gcc/config/arm/arm.c	2018-10-01 13:54:18.000000000 +0300
@@ -18483,12 +18483,18 @@
       gcc_assert ((REGNO (operands[1]) != IP_REGNUM)
                   || (TARGET_ARM && TARGET_LDRD));
 
+      /* For TARGET_ARM the first source register of an STRD
+	 must be even.  This is usually the case for double-word
+	 values but user assembly constraints can force an odd
+	 starting register.  */
+      bool allow_strd = TARGET_LDRD
+			 && !(TARGET_ARM && (REGNO (operands[1]) & 1) == 1);
       switch (GET_CODE (XEXP (operands[0], 0)))
         {
 	case REG:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (allow_strd)
 		output_asm_insn ("strd%?\t%1, [%m0]", operands);
 	      else
 		output_asm_insn ("stm%?\t%m0, %M1", operands);
@@ -18496,7 +18502,7 @@
 	  break;
 
         case PRE_INC:
-	  gcc_assert (TARGET_LDRD);
+	  gcc_assert (allow_strd);
 	  if (emit)
 	    output_asm_insn ("strd%?\t%1, [%m0, #8]!", operands);
 	  break;
@@ -18504,7 +18510,7 @@
         case PRE_DEC:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (allow_strd)
 		output_asm_insn ("strd%?\t%1, [%m0, #-8]!", operands);
 	      else
 		output_asm_insn ("stmdb%?\t%m0!, %M1", operands);
@@ -18514,7 +18520,7 @@
         case POST_INC:
 	  if (emit)
 	    {
-	      if (TARGET_LDRD)
+	      if (allow_strd)
 		output_asm_insn ("strd%?\t%1, [%m0], #8", operands);
 	      else
 		output_asm_insn ("stm%?\t%m0!, %M1", operands);
@@ -18522,7 +18528,7 @@
 	  break;
 
         case POST_DEC:
-	  gcc_assert (TARGET_LDRD);
+	  gcc_assert (allow_strd);
 	  if (emit)
 	    output_asm_insn ("strd%?\t%1, [%m0], #-8", operands);
 	  break;
@@ -18533,8 +18539,8 @@
 	  otherops[1] = XEXP (XEXP (XEXP (operands[0], 0), 1), 0);
 	  otherops[2] = XEXP (XEXP (XEXP (operands[0], 0), 1), 1);
 
-	  /* IWMMXT allows offsets larger than ldrd can handle,
-	     fix these up with a pair of ldr.  */
+	  /* IWMMXT allows offsets larger than strd can handle,
+	     fix these up with a pair of str.  */
 	  if (!TARGET_THUMB2
 	      && CONST_INT_P (otherops[2])
 	      && (INTVAL(otherops[2]) <= -256
@@ -18599,7 +18605,7 @@
 		  return "";
 		}
 	    }
-	  if (TARGET_LDRD
+	  if (allow_strd
 	      && (REG_P (otherops[2])
 		  || TARGET_THUMB2
 		  || (CONST_INT_P (otherops[2])
@@ -30059,7 +30065,6 @@
   rtx dst, addr, mem;
   rtx val_vec, reg;
   machine_mode mode;
-  unsigned HOST_WIDE_INT v = value;
   unsigned int offset = 0;
 
   gcc_assert ((align & 0x3) == 0);
@@ -30078,10 +30083,8 @@
 
   dst = copy_addr_to_reg (XEXP (dstbase, 0));
 
-  v = sext_hwi (v, BITS_PER_WORD);
-
   reg = gen_reg_rtx (mode);
-  val_vec = gen_const_vec_duplicate (mode, GEN_INT (v));
+  val_vec = gen_const_vec_duplicate (mode, gen_int_mode (value, QImode));
   /* Emit instruction loading the constant value.  */
   emit_move_insn (reg, val_vec);
 
diff -Naur gcc-8.2.0/gcc/config/i386/avx512fintrin.h gcc-8-20181012/gcc/config/i386/avx512fintrin.h
--- gcc-8.2.0/gcc/config/i386/avx512fintrin.h	2018-07-12 00:02:54.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/avx512fintrin.h	2018-10-08 18:20:08.000000000 +0300
@@ -3762,7 +3762,7 @@
     (__m512d)__builtin_ia32_vfmaddsubpd512_mask(A, B, C, -1, R)
 
 #define _mm512_mask_fmaddsub_round_pd(A, U, B, C, R)    \
-    (__m512d)__builtin_ia32_vfmaddpd512_mask(A, B, C, U, R)
+    (__m512d)__builtin_ia32_vfmaddsubpd512_mask(A, B, C, U, R)
 
 #define _mm512_mask3_fmaddsub_round_pd(A, B, C, U, R)   \
     (__m512d)__builtin_ia32_vfmaddsubpd512_mask3(A, B, C, U, R)
@@ -7727,7 +7727,7 @@
 
 extern __inline __m512d
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_abs_pd (__m512 __A)
+_mm512_abs_pd (__m512d __A)
 {
   return (__m512d) _mm512_and_epi64 ((__m512i) __A,
 				     _mm512_set1_epi64 (0x7fffffffffffffffLL));
@@ -7735,7 +7735,7 @@
 
 extern __inline __m512d
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
-_mm512_mask_abs_pd (__m512d __W, __mmask8 __U, __m512 __A)
+_mm512_mask_abs_pd (__m512d __W, __mmask8 __U, __m512d __A)
 {
   return (__m512d)
 	 _mm512_mask_and_epi64 ((__m512i) __W, __U, (__m512i) __A,
diff -Naur gcc-8.2.0/gcc/config/i386/djgpp.c gcc-8-20181012/gcc/config/i386/djgpp.c
--- gcc-8.2.0/gcc/config/i386/djgpp.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/djgpp.c	2018-08-01 09:53:34.000000000 +0300
@@ -47,3 +47,20 @@
 
   fprintf (asm_out_file, "\t.section\t%s,\"%s\"\n", name, flagchars);
 }
+
+/* Kludge because of missing COFF support for early LTO debug.  */
+
+static enum debug_info_levels saved_debug_info_level;
+
+void
+i386_djgpp_asm_lto_start (void)
+{
+  saved_debug_info_level = debug_info_level;
+  debug_info_level = DINFO_LEVEL_NONE;
+}
+
+void
+i386_djgpp_asm_lto_end (void)
+{
+  debug_info_level = saved_debug_info_level;
+}
diff -Naur gcc-8.2.0/gcc/config/i386/djgpp.h gcc-8-20181012/gcc/config/i386/djgpp.h
--- gcc-8.2.0/gcc/config/i386/djgpp.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/djgpp.h	2018-08-01 09:53:34.000000000 +0300
@@ -160,8 +160,19 @@
 #undef MAKE_DECL_ONE_ONLY
 #define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)
 
+#undef TARGET_COFF
+#define TARGET_COFF 1
+
+/* Kludge because of missing COFF support for early LTO debug.  */
+#undef  TARGET_ASM_LTO_START
+#define TARGET_ASM_LTO_START i386_djgpp_asm_lto_start
+#undef  TARGET_ASM_LTO_END
+#define TARGET_ASM_LTO_END i386_djgpp_asm_lto_end
+
 /* Function protypes for gcc/i386/djgpp.c */
 
 void
 i386_djgpp_asm_named_section(const char *name, unsigned int flags,
 			     tree decl);
+void i386_djgpp_asm_lto_start (void);
+void i386_djgpp_asm_lto_end (void);
diff -Naur gcc-8.2.0/gcc/config/i386/gnu-user.h gcc-8-20181012/gcc/config/i386/gnu-user.h
--- gcc-8.2.0/gcc/config/i386/gnu-user.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/gnu-user.h	2018-10-05 14:31:45.000000000 +0300
@@ -67,7 +67,7 @@
 
 #undef  ASM_SPEC
 #define ASM_SPEC \
-  "--32 %{!mno-sse2avx:%{mavx:-msse2avx}} %{msse2avx:%{!mavx:-msse2avx}}"
+  "--32 %{msse2avx:%{!mavx:-msse2avx}}"
 
 #undef  SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS \
diff -Naur gcc-8.2.0/gcc/config/i386/gnu-user64.h gcc-8-20181012/gcc/config/i386/gnu-user64.h
--- gcc-8.2.0/gcc/config/i386/gnu-user64.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/gnu-user64.h	2018-10-05 14:31:45.000000000 +0300
@@ -50,7 +50,7 @@
 #define ASM_SPEC "%{" SPEC_32 ":--32} \
  %{" SPEC_64 ":--64} \
  %{" SPEC_X32 ":--x32} \
- %{!mno-sse2avx:%{mavx:-msse2avx}} %{msse2avx:%{!mavx:-msse2avx}}"
+ %{msse2avx:%{!mavx:-msse2avx}}"
 
 #define GNU_USER_TARGET_LINK_SPEC				   \
                   "%{" SPEC_64 ":-m " GNU_USER_LINK_EMULATION64 "} \
diff -Naur gcc-8.2.0/gcc/config/i386/i386.c gcc-8-20181012/gcc/config/i386/i386.c
--- gcc-8.2.0/gcc/config/i386/i386.c	2018-07-13 23:36:01.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/i386.c	2018-10-11 20:40:31.000000000 +0300
@@ -91,6 +91,8 @@
 #include "ipa-prop.h"
 #include "ipa-fnsummary.h"
 #include "wide-int-bitmask.h"
+#include "debug.h"
+#include "dwarf2out.h"
 
 /* This file should be included last.  */
 #include "target-def.h"
@@ -2606,11 +2608,17 @@
 			 TYPE_ATTRIBUTES (TREE_TYPE (cfun->decl)))
       && !cgraph_node::get (cfun->decl)->only_called_directly_p ())
     {
-      cet_eb = gen_nop_endbr ();
+      /* Queue ENDBR insertion to x86_function_profiler.  */
+      if (crtl->profile && flag_fentry)
+	cfun->machine->endbr_queued_at_entrance = true;
+      else
+	{
+	  cet_eb = gen_nop_endbr ();
 
-      bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
-      insn = BB_HEAD (bb);
-      emit_insn_before (cet_eb, insn);
+	  bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
+	  insn = BB_HEAD (bb);
+	  emit_insn_before (cet_eb, insn);
+	}
     }
 
   bb = 0;
@@ -8193,7 +8201,7 @@
       case X86_64_SSEDF_CLASS:
 	if (mode != BLKmode)
 	  return gen_reg_or_parallel (mode, orig_mode,
-				      SSE_REGNO (sse_regno));
+				      GET_SSE_REGNO (sse_regno));
 	break;
       case X86_64_X87_CLASS:
       case X86_64_COMPLEX_X87_CLASS:
@@ -8209,7 +8217,7 @@
       && regclass[1] == X86_64_SSEUP_CLASS
       && mode != BLKmode)
     return gen_reg_or_parallel (mode, orig_mode,
-				SSE_REGNO (sse_regno));
+				GET_SSE_REGNO (sse_regno));
   if (n == 4
       && regclass[0] == X86_64_SSE_CLASS
       && regclass[1] == X86_64_SSEUP_CLASS
@@ -8217,7 +8225,7 @@
       && regclass[3] == X86_64_SSEUP_CLASS
       && mode != BLKmode)
     return gen_reg_or_parallel (mode, orig_mode,
-				SSE_REGNO (sse_regno));
+				GET_SSE_REGNO (sse_regno));
   if (n == 8
       && regclass[0] == X86_64_SSE_CLASS
       && regclass[1] == X86_64_SSEUP_CLASS
@@ -8229,7 +8237,7 @@
       && regclass[7] == X86_64_SSEUP_CLASS
       && mode != BLKmode)
     return gen_reg_or_parallel (mode, orig_mode,
-				SSE_REGNO (sse_regno));
+				GET_SSE_REGNO (sse_regno));
   if (n == 2
       && regclass[0] == X86_64_X87_CLASS
       && regclass[1] == X86_64_X87UP_CLASS)
@@ -8238,9 +8246,22 @@
   if (n == 2
       && regclass[0] == X86_64_INTEGER_CLASS
       && regclass[1] == X86_64_INTEGER_CLASS
-      && (mode == CDImode || mode == TImode)
+      && (mode == CDImode || mode == TImode || mode == BLKmode)
       && intreg[0] + 1 == intreg[1])
-    return gen_rtx_REG (mode, intreg[0]);
+    {
+      if (mode == BLKmode)
+	{
+	  /* Use TImode for BLKmode values in 2 integer registers.  */
+	  exp[0] = gen_rtx_EXPR_LIST (VOIDmode,
+				      gen_rtx_REG (TImode, intreg[0]),
+				      GEN_INT (0));
+	  ret = gen_rtx_PARALLEL (mode, rtvec_alloc (1));
+	  XVECEXP (ret, 0, 0) = exp[0];
+	  return ret;
+	}
+      else
+	return gen_rtx_REG (mode, intreg[0]);
+    }
 
   /* Otherwise figure out the entries of the PARALLEL.  */
   for (i = 0; i < n; i++)
@@ -8276,7 +8297,7 @@
 	    exp [nexps++]
 	      = gen_rtx_EXPR_LIST (VOIDmode,
 				   gen_rtx_REG (SFmode,
-						SSE_REGNO (sse_regno)),
+						GET_SSE_REGNO (sse_regno)),
 				   GEN_INT (i*8));
 	    sse_regno++;
 	    break;
@@ -8284,7 +8305,7 @@
 	    exp [nexps++]
 	      = gen_rtx_EXPR_LIST (VOIDmode,
 				   gen_rtx_REG (DFmode,
-						SSE_REGNO (sse_regno)),
+						GET_SSE_REGNO (sse_regno)),
 				   GEN_INT (i*8));
 	    sse_regno++;
 	    break;
@@ -8330,7 +8351,7 @@
 	    exp [nexps++]
 	      = gen_rtx_EXPR_LIST (VOIDmode,
 				   gen_rtx_REG (tmpmode,
-						SSE_REGNO (sse_regno)),
+						GET_SSE_REGNO (sse_regno)),
 				   GEN_INT (pos*8));
 	    sse_regno++;
 	    break;
@@ -9766,7 +9787,7 @@
 	  set_mem_alias_set (mem, set);
 	  set_mem_align (mem, GET_MODE_ALIGNMENT (smode));
 
-	  emit_move_insn (mem, gen_rtx_REG (smode, SSE_REGNO (i)));
+	  emit_move_insn (mem, gen_rtx_REG (smode, GET_SSE_REGNO (i)));
 	}
 
       emit_label (label);
@@ -10995,6 +11016,23 @@
 
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
+  /* The above call insn pushed a word to stack.  Adjust CFI info.  */
+  if (flag_asynchronous_unwind_tables && dwarf2out_do_frame ())
+    {
+      if (! dwarf2out_do_cfi_asm ())
+	{
+	  dw_cfi_ref xcfi = ggc_cleared_alloc<dw_cfi_node> ();
+	  xcfi->dw_cfi_opc = DW_CFA_advance_loc4;
+	  xcfi->dw_cfi_oprnd1.dw_cfi_addr = ggc_strdup (indirectlabel2);
+	  vec_safe_push (cfun->fde->dw_fde_cfi, xcfi);
+	}
+      dw_cfi_ref xcfi = ggc_cleared_alloc<dw_cfi_node> ();
+      xcfi->dw_cfi_opc = DW_CFA_def_cfa_offset;
+      xcfi->dw_cfi_oprnd1.dw_cfi_offset = 2 * UNITS_PER_WORD;
+      vec_safe_push (cfun->fde->dw_fde_cfi, xcfi);
+      dwarf2out_emit_cfi (xcfi);
+    }
+
   if (regno != INVALID_REGNUM)
     {
       /* MOV.  */
@@ -13438,12 +13476,14 @@
 	  recompute_frame_layout_p = true;
 	}
     }
-  else if (crtl->max_used_stack_slot_alignment
-	   > crtl->preferred_stack_boundary)
+  else if (crtl->max_used_stack_slot_alignment >= 128)
     {
-      /* We don't need to realign stack.  But we still need to keep
-	 stack frame properly aligned to satisfy the largest alignment
-	 of stack slots.  */
+      /* We don't need to realign stack.  max_used_stack_alignment is
+	 used to decide how stack frame should be aligned.  This is
+	 independent of any psABIs nor 32-bit vs 64-bit.  It is always
+	 safe to compute max_used_stack_alignment.  We compute it only
+	 if 128-bit aligned load/store may be generated on misaligned
+	 stack slot which will lead to segfault.   */
       if (ix86_find_max_used_stack_alignment (stack_alignment, true))
 	cfun->machine->max_used_stack_alignment
 	  = stack_alignment / BITS_PER_UNIT;
@@ -41972,6 +42012,10 @@
 {
   const char *mcount_name = (flag_fentry ? MCOUNT_NAME_BEFORE_PROLOGUE
 					 : MCOUNT_NAME);
+
+  if (cfun->machine->endbr_queued_at_entrance)
+    fprintf (file, "\t%s\n", TARGET_64BIT ? "endbr64" : "endbr32");
+
   if (TARGET_64BIT)
     {
 #ifndef NO_PROFILE_COUNTERS
diff -Naur gcc-8.2.0/gcc/config/i386/i386.h gcc-8-20181012/gcc/config/i386/i386.h
--- gcc-8.2.0/gcc/config/i386/i386.h	2018-04-20 16:30:13.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/i386.h	2018-10-03 23:31:49.000000000 +0300
@@ -1536,10 +1536,10 @@
 #define FIRST_FLOAT_REG FIRST_STACK_REG
 #define STACK_TOP_P(X) (REG_P (X) && REGNO (X) == FIRST_FLOAT_REG)
 
-#define SSE_REGNO(N) \
-  ((N) < 8 ? FIRST_SSE_REG + (N) \
-         : (N) <= LAST_REX_SSE_REG ? (FIRST_REX_SSE_REG + (N) - 8) \
-                                   : (FIRST_EXT_REX_SSE_REG + (N) - 16))
+#define GET_SSE_REGNO(N)			\
+  ((N) < 8 ? FIRST_SSE_REG + (N)		\
+   : (N) < 16 ? FIRST_REX_SSE_REG + (N) - 8	\
+   : FIRST_EXT_REX_SSE_REG + (N) - 16)
 
 /* The class value for index registers, and the one for base regs.  */
 
@@ -2635,6 +2635,9 @@
   /* Nonzero if the function places outgoing arguments on stack.  */
   BOOL_BITFIELD outgoing_args_on_stack : 1;
 
+  /* If true, ENDBR is queued at function entrance.  */
+  BOOL_BITFIELD endbr_queued_at_entrance : 1;
+
   /* The largest alignment, in bytes, of stack slot actually used.  */
   unsigned int max_used_stack_alignment;
 
diff -Naur gcc-8.2.0/gcc/config/i386/i386.md gcc-8-20181012/gcc/config/i386/i386.md
--- gcc-8.2.0/gcc/config/i386/i386.md	2018-06-26 14:46:10.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/i386.md	2018-08-21 19:17:35.000000000 +0300
@@ -13345,7 +13345,10 @@
      stack address we wish to restore.  */
   tmp = gen_rtx_PLUS (Pmode, arg_pointer_rtx, sa);
   tmp = plus_constant (Pmode, tmp, -UNITS_PER_WORD);
-  tmp = gen_rtx_MEM (Pmode, tmp);
+  /* Return address is always in word_mode.  */
+  tmp = gen_rtx_MEM (word_mode, tmp);
+  if (GET_MODE (ra) != word_mode)
+    ra = convert_to_mode (word_mode, ra, 1);
   emit_move_insn (tmp, ra);
 
   emit_jump_insn (gen_eh_return_internal ());
diff -Naur gcc-8.2.0/gcc/config/i386/i386-builtin.def gcc-8-20181012/gcc/config/i386/i386-builtin.def
--- gcc-8.2.0/gcc/config/i386/i386-builtin.def	2018-04-19 18:08:02.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/i386-builtin.def	2018-10-11 20:41:33.000000000 +0300
@@ -90,6 +90,7 @@
 BDESC_FIRST (special_args, SPECIAL_ARGS,
        0, CODE_FOR_nothing, "__builtin_ia32_rdtsc", IX86_BUILTIN_RDTSC, UNKNOWN, (int) UINT64_FTYPE_VOID)
 BDESC (0, CODE_FOR_nothing, "__builtin_ia32_rdtscp", IX86_BUILTIN_RDTSCP, UNKNOWN, (int) UINT64_FTYPE_PUNSIGNED)
+BDESC (0, CODE_FOR_nothing, "__builtin_ia32_rdpmc", IX86_BUILTIN_RDPMC, UNKNOWN, (int) UINT64_FTYPE_INT)
 BDESC (0, CODE_FOR_pause, "__builtin_ia32_pause", IX86_BUILTIN_PAUSE, UNKNOWN, (int) VOID_FTYPE_VOID)
 
 /* 80387 (for use internally for atomic compound assignment).  */
@@ -427,7 +428,6 @@
 BDESC_FIRST (args, ARGS,
        0, CODE_FOR_bsr, "__builtin_ia32_bsrsi", IX86_BUILTIN_BSRSI, UNKNOWN, (int) INT_FTYPE_INT)
 BDESC (OPTION_MASK_ISA_64BIT, CODE_FOR_bsr_rex64, "__builtin_ia32_bsrdi", IX86_BUILTIN_BSRDI, UNKNOWN, (int) INT64_FTYPE_INT64)
-BDESC (0, CODE_FOR_nothing, "__builtin_ia32_rdpmc", IX86_BUILTIN_RDPMC, UNKNOWN, (int) UINT64_FTYPE_INT)
 BDESC (0, CODE_FOR_rotlqi3, "__builtin_ia32_rolqi", IX86_BUILTIN_ROLQI, UNKNOWN, (int) UINT8_FTYPE_UINT8_INT)
 BDESC (0, CODE_FOR_rotlhi3, "__builtin_ia32_rolhi", IX86_BUILTIN_ROLHI, UNKNOWN, (int) UINT16_FTYPE_UINT16_INT)
 BDESC (0, CODE_FOR_rotrqi3, "__builtin_ia32_rorqi", IX86_BUILTIN_RORQI, UNKNOWN, (int) UINT8_FTYPE_UINT8_INT)
diff -Naur gcc-8.2.0/gcc/config/i386/predicates.md gcc-8-20181012/gcc/config/i386/predicates.md
--- gcc-8.2.0/gcc/config/i386/predicates.md	2018-02-26 20:00:46.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/predicates.md	2018-10-03 23:31:49.000000000 +0300
@@ -1517,7 +1517,7 @@
       if (GET_CODE (elt) != SET
 	  || GET_CODE (SET_DEST (elt)) != REG
 	  || GET_MODE (SET_DEST (elt)) != V8SImode
-	  || REGNO (SET_DEST (elt)) != SSE_REGNO (i)
+	  || REGNO (SET_DEST (elt)) != GET_SSE_REGNO (i)
 	  || SET_SRC (elt) != CONST0_RTX (V8SImode))
 	return false;
     }
diff -Naur gcc-8.2.0/gcc/config/i386/sse.md gcc-8-20181012/gcc/config/i386/sse.md
--- gcc-8.2.0/gcc/config/i386/sse.md	2018-05-25 00:27:24.000000000 +0300
+++ gcc-8-20181012/gcc/config/i386/sse.md	2018-10-03 23:31:49.000000000 +0300
@@ -17475,7 +17475,7 @@
 
   for (regno = 0; regno < nregs; regno++)
     XVECEXP (operands[0], 0, regno + 1)
-      = gen_rtx_SET (gen_rtx_REG (V8SImode, SSE_REGNO (regno)),
+      = gen_rtx_SET (gen_rtx_REG (V8SImode, GET_SSE_REGNO (regno)),
 		     CONST0_RTX (V8SImode));
 })
 
diff -Naur gcc-8.2.0/gcc/config/m68k/m68k.md gcc-8-20181012/gcc/config/m68k/m68k.md
--- gcc-8.2.0/gcc/config/m68k/m68k.md	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/m68k/m68k.md	2018-08-02 20:23:13.000000000 +0300
@@ -3240,7 +3240,10 @@
 	  (const_int 32))))
    (clobber (match_operand:SI 1 "register_operand" "=d"))]
   "TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE"
-  "mulu%.l %3,%0:%1")
+{
+  CC_STATUS_INIT;
+  return "mulu%.l %3,%0:%1";
+})
 
 (define_insn "const_umulsi3_highpart"
   [(set (match_operand:SI 0 "register_operand" "=d")
@@ -3251,7 +3254,10 @@
 	  (const_int 32))))
    (clobber (match_operand:SI 1 "register_operand" "=d"))]
   "TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE"
-  "mulu%.l %3,%0:%1")
+{
+  CC_STATUS_INIT;
+  return "mulu%.l %3,%0:%1";
+})
 
 (define_expand "smulsi3_highpart"
   [(parallel
@@ -3283,7 +3289,10 @@
 	  (const_int 32))))
    (clobber (match_operand:SI 1 "register_operand" "=d"))]
   "TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE"
-  "muls%.l %3,%0:%1")
+{
+  CC_STATUS_INIT;
+  return "muls%.l %3,%0:%1";
+})
 
 (define_insn "const_smulsi3_highpart"
   [(set (match_operand:SI 0 "register_operand" "=d")
@@ -3294,7 +3303,10 @@
 	  (const_int 32))))
    (clobber (match_operand:SI 1 "register_operand" "=d"))]
   "TARGET_68020 && !TUNE_68060 && !TARGET_COLDFIRE"
-  "muls%.l %3,%0:%1")
+{
+  CC_STATUS_INIT;
+  return "muls%.l %3,%0:%1";
+})
 
 (define_expand "mul<mode>3"
   [(set (match_operand:FP 0 "nonimmediate_operand" "")
diff -Naur gcc-8.2.0/gcc/config/mmix/mmix.c gcc-8-20181012/gcc/config/mmix/mmix.c
--- gcc-8.2.0/gcc/config/mmix/mmix.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/config/mmix/mmix.c	2018-09-17 00:23:36.000000000 +0300
@@ -60,19 +60,16 @@
 
 /* We have no means to tell DWARF 2 about the register stack, so we need
    to store the return address on the stack if an exception can get into
-   this function.  FIXME: Narrow condition.  Before any whole-function
-   analysis, df_regs_ever_live_p () isn't initialized.  We know it's up-to-date
-   after reload_completed; it may contain incorrect information some time
-   before that.  Within a RTL sequence (after a call to start_sequence,
-   such as in RTL expanders), leaf_function_p doesn't see all insns
-   (perhaps any insn).  But regs_ever_live is up-to-date when
-   leaf_function_p () isn't, so we "or" them together to get accurate
-   information.  FIXME: Some tweak to leaf_function_p might be
-   preferable.  */
+   this function.  We'll have an "initial value" recorded for the
+   return-register if we've seen a call instruction emitted.  This note
+   will be inaccurate before instructions are emitted, but the only caller
+   at that time is looking for modulo from stack-boundary, to which the
+   return-address does not contribute, and which is always 0 for MMIX
+   anyway.  Beware of calling leaf_function_p here, as it'll abort if
+   called within a sequence.  */
 #define MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS			\
  (flag_exceptions						\
-  && ((reload_completed && df_regs_ever_live_p (MMIX_rJ_REGNUM))	\
-      || !leaf_function_p ()))
+  && has_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM))
 
 #define IS_MMIX_EH_RETURN_DATA_REG(REGNO)	\
  (crtl->calls_eh_return		\
@@ -1373,8 +1370,14 @@
       case 1:
 	if (GET_CODE (x) != CONST_INT)
 	  {
-	    aligned_p = 0;
-	    break;
+	    /* There is no "unaligned byte" op or generic function to
+	       which we can punt, so we have to handle this here.  As
+	       the expression isn't a plain literal, the generated
+	       assembly-code can't be mmixal-equivalent (i.e. "BYTE"
+	       won't work) and thus it's ok to emit the default op
+	       ".byte". */
+	    assemble_integer_with_op ("\t.byte\t", x);
+	    return true;
 	  }
 	fputs ("\tBYTE\t", asm_out_file);
 	mmix_print_operand (asm_out_file, x, 'B');
diff -Naur gcc-8.2.0/gcc/config/pa/pa.c gcc-8-20181012/gcc/config/pa/pa.c
--- gcc-8.2.0/gcc/config/pa/pa.c	2018-03-15 02:31:57.000000000 +0300
+++ gcc-8-20181012/gcc/config/pa/pa.c	2018-07-29 18:54:08.000000000 +0300
@@ -10680,6 +10680,8 @@
 {
   int idx, vlen = XVECLEN (body, 0);
 
+  if (!TARGET_SOM)
+    fputs ("\t.align 4\n", asm_out_file);
   targetm.asm_out.internal_label (asm_out_file, "L", CODE_LABEL_NUMBER (lab));
   if (TARGET_GAS)
     fputs ("\t.begin_brtab\n", asm_out_file);
diff -Naur gcc-8.2.0/gcc/config/pa/pa.h gcc-8-20181012/gcc/config/pa/pa.h
--- gcc-8.2.0/gcc/config/pa/pa.h	2018-03-07 03:47:41.000000000 +0300
+++ gcc-8-20181012/gcc/config/pa/pa.h	2018-07-29 18:54:08.000000000 +0300
@@ -1143,21 +1143,23 @@
 #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \
   pa_output_ascii ((FILE), (P), (SIZE))
 
-/* Jump tables are always placed in the text section.  Technically, it
-   is possible to put them in the readonly data section.  This has the
-   benefit of getting the table out of .text and reducing branch lengths
-   as a result.
+/* Jump tables are always placed in the text section.  We have to do
+   this for the HP-UX SOM target as we can't switch sections in the
+   middle of a function.
 
-   The downside is that an additional insn (addil) is needed to access
+   On ELF targets, it is possible to put them in the readonly-data section.
+   This would get the table out of .text and reduce branch lengths.
+
+   A downside is that an additional insn (addil) is needed to access
    the table when generating PIC code.  The address difference table
-   also has to use 32-bit pc-relative relocations.  Currently, GAS does
-   not support these relocations, although it is easily modified to do
-   this operation.
+   also has to use 32-bit pc-relative relocations.
 
    The table entries need to look like "$L1+(.+8-$L0)-$PIC_pcrel$0"
    when using ELF GAS.  A simple difference can be used when using
-   SOM GAS or the HP assembler.  The final downside is GDB complains
-   about the nesting of the label for the table when debugging.  */
+   the HP assembler.
+
+   The final downside is GDB complains about the nesting of the label
+   for the table.  */
 
 #define JUMP_TABLES_IN_TEXT_SECTION 1
 
diff -Naur gcc-8.2.0/gcc/config/pa/pa.md gcc-8-20181012/gcc/config/pa/pa.md
--- gcc-8.2.0/gcc/config/pa/pa.md	2018-02-15 00:13:26.000000000 +0300
+++ gcc-8-20181012/gcc/config/pa/pa.md	2018-09-20 04:07:42.000000000 +0300
@@ -84,6 +84,7 @@
    UNSPEC_TLSGD_PIC
    UNSPEC_TLSLDM_PIC
    UNSPEC_TLSIE_PIC
+   UNSPEC_MEMORY_BARRIER
   ])
 
 ;; UNSPEC_VOLATILE:
@@ -9955,14 +9956,8 @@
 ;; doubleword loads and stores are not guaranteed to be atomic
 ;; when referencing the I/O address space.
 
-;; The kernel cmpxchg operation on linux is not atomic with respect to
-;; memory stores on SMP machines, so we must do stores using a cmpxchg
-;; operation.
-
 ;; These patterns are at the bottom so the non atomic versions are preferred.
 
-;; Implement atomic QImode store using exchange.
-
 (define_expand "atomic_storeqi"
   [(match_operand:QI 0 "memory_operand")                ;; memory
    (match_operand:QI 1 "register_operand")              ;; val out
@@ -10015,25 +10010,7 @@
   FAIL;
 })
 
-;; Implement atomic SFmode store using exchange.
-
-(define_expand "atomic_storesf"
-  [(match_operand:SF 0 "memory_operand")                ;; memory
-   (match_operand:SF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
-  ""
-{
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-  FAIL;
-})
-
-;; Implement atomic DImode load using 64-bit floating point load.
+;; Implement atomic DImode load.
 
 (define_expand "atomic_loaddi"
   [(match_operand:DI 0 "register_operand")              ;; val out
@@ -10048,29 +10025,27 @@
 
   model = memmodel_from_int (INTVAL (operands[2]));
   operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
   if (is_mm_seq_cst (model))
     expand_mem_thread_fence (model);
+  emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));
+  expand_mem_thread_fence (model);
   DONE;
 })
 
 (define_insn "atomic_loaddi_1"
-  [(set (match_operand:DI 0 "register_operand" "=f,r")
-        (mem:DI (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DI 2 "=X,f"))]
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (mem:DI (match_operand:SI 1 "register_operand" "r")))
+   (clobber (match_scratch:DI 2 "=f"))]
   "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
+  "{fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
+  [(set_attr "type" "move")
+   (set_attr "length" "16")])
 
 ;; Implement atomic DImode store.
 
 (define_expand "atomic_storedi"
   [(match_operand:DI 0 "memory_operand")                ;; memory
-   (match_operand:DI 1 "register_operand")              ;; val out
+   (match_operand:DI 1 "reg_or_cint_move_operand")      ;; val out
    (match_operand:SI 2 "const_int_operand")]            ;; model
   ""
 {
@@ -10089,6 +10064,8 @@
 
   model = memmodel_from_int (INTVAL (operands[2]));
   operands[0] = force_reg (SImode, XEXP (operands[0], 0));
+  if (operands[1] != CONST0_RTX (DImode))
+    operands[1] = force_reg (DImode, operands[1]);
   expand_mem_thread_fence (model);
   emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));
   if (is_mm_seq_cst (model))
@@ -10098,87 +10075,33 @@
 
 (define_insn "atomic_storedi_1"
   [(set (mem:DI (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DI 1 "register_operand" "f,r"))
+        (match_operand:DI 1 "reg_or_0_operand" "M,r"))
    (clobber (match_scratch:DI 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
+  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
   "@
-   {fstds|fstd} %1,0(%0)
+   {fstds|fstd} %%fr0,0(%0)
    {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
   [(set_attr "type" "move,move")
    (set_attr "length" "4,16")])
 
-;; Implement atomic DFmode load using 64-bit floating point load.
-
-(define_expand "atomic_loaddf"
-  [(match_operand:DF 0 "register_operand")              ;; val out
-   (match_operand:DF 1 "memory_operand")                ;; memory
-   (match_operand:SI 2 "const_int_operand")]            ;; model
+;; PA 2.0 hardware supports out-of-order execution of loads and stores, so
+;; we need a memory barrier to enforce program order for memory references.
+;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the
+;; barrier when generating PA 1.x code.
+
+(define_expand "memory_barrier"
+  [(set (match_dup 0)
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
   ""
 {
-  enum memmodel model;
-
-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[1] = force_reg (SImode, XEXP (operands[1], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_loaddf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
 })
 
-(define_insn "atomic_loaddf_1"
-  [(set (match_operand:DF 0 "register_operand" "=f,r")
-        (mem:DF (match_operand:SI 1 "register_operand" "r,r")))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS && !TARGET_SOFT_FLOAT"
-  "@
-   {fldds|fldd} 0(%1),%0
-   {fldds|fldd} 0(%1),%2\n\t{fstds|fstd} %2,-16(%%sp)\n\t{ldws|ldw} -16(%%sp),%0\n\t{ldws|ldw} -12(%%sp),%R0"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
-
-;; Implement atomic DFmode store using 64-bit floating point store.
-
-(define_expand "atomic_storedf"
-  [(match_operand:DF 0 "memory_operand")                ;; memory
-   (match_operand:DF 1 "register_operand")              ;; val out
-   (match_operand:SI 2 "const_int_operand")]            ;; model
+(define_insn "*memory_barrier"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
   ""
-{
-  enum memmodel model;
-
-  if (TARGET_SYNC_LIBCALL)
-    {
-      rtx mem = operands[0];
-      rtx val = operands[1];
-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))
-	DONE;
-    }
-
-  if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)
-    FAIL;
-
-  model = memmodel_from_int (INTVAL (operands[2]));
-  operands[0] = force_reg (SImode, XEXP (operands[0], 0));
-  expand_mem_thread_fence (model);
-  emit_insn (gen_atomic_storedf_1 (operands[0], operands[1]));
-  if (is_mm_seq_cst (model))
-    expand_mem_thread_fence (model);
-  DONE;
-})
-
-(define_insn "atomic_storedf_1"
-  [(set (mem:DF (match_operand:SI 0 "register_operand" "r,r"))
-        (match_operand:DF 1 "register_operand" "f,r"))
-   (clobber (match_scratch:DF 2 "=X,f"))]
-  "!TARGET_64BIT && !TARGET_DISABLE_FPREGS
-   && !TARGET_SOFT_FLOAT && !TARGET_SYNC_LIBCALL"
-  "@
-   {fstds|fstd} %1,0(%0)
-   {stws|stw} %1,-16(%%sp)\n\t{stws|stw} %R1,-12(%%sp)\n\t{fldds|fldd} -16(%%sp),%2\n\t{fstds|fstd} %2,0(%0)"
-  [(set_attr "type" "move,move")
-   (set_attr "length" "4,16")])
+  "sync"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
diff -Naur gcc-8.2.0/gcc/config/pa/pa32-linux.h gcc-8-20181012/gcc/config/pa/pa32-linux.h
--- gcc-8.2.0/gcc/config/pa/pa32-linux.h	2018-01-17 03:19:05.000000000 +0300
+++ gcc-8-20181012/gcc/config/pa/pa32-linux.h	2018-07-29 18:54:08.000000000 +0300
@@ -67,3 +67,12 @@
    layout compatibility with the original linux thread implementation.  */
 #undef MALLOC_ABI_ALIGNMENT
 #define MALLOC_ABI_ALIGNMENT 128
+
+/* Place jump tables in the text section except when generating non-PIC
+   code.  When generating non-PIC code, the relocations needed to load the
+   address of the jump table result in a text label in the final executable
+   if the jump table is placed in the text section.  This breaks the unwind
+   data for the function.  Thus, the jump table needs to be placed in
+   rodata when generating non-PIC code.  */
+#undef JUMP_TABLES_IN_TEXT_SECTION
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
diff -Naur gcc-8.2.0/gcc/config/rs6000/emmintrin.h gcc-8-20181012/gcc/config/rs6000/emmintrin.h
--- gcc-8.2.0/gcc/config/rs6000/emmintrin.h	2018-07-15 20:55:44.000000000 +0300
+++ gcc-8-20181012/gcc/config/rs6000/emmintrin.h	2018-09-14 18:43:35.000000000 +0300
@@ -85,6 +85,9 @@
 typedef long long __m128i_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));
 typedef double __m128d_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));
 
+/* Define two value permute mask */
+#define _MM_SHUFFLE2(x,y) (((x) << 1) | (y))
+
 /* Create a vector with element 0 as F and the rest zero.  */
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_set_sd (double __F)
diff -Naur gcc-8.2.0/gcc/config/rs6000/rs6000.c gcc-8-20181012/gcc/config/rs6000/rs6000.c
--- gcc-8.2.0/gcc/config/rs6000/rs6000.c	2018-07-03 00:25:10.000000000 +0300
+++ gcc-8-20181012/gcc/config/rs6000/rs6000.c	2018-10-09 23:55:25.000000000 +0300
@@ -8519,7 +8519,9 @@
     *tocrel_offset_ret = tocrel_offset;
 
   return (GET_CODE (tocrel_base) == UNSPEC
-	  && XINT (tocrel_base, 1) == UNSPEC_TOCREL);
+	  && XINT (tocrel_base, 1) == UNSPEC_TOCREL
+	  && REG_P (XVECEXP (tocrel_base, 0, 1))
+	  && REGNO (XVECEXP (tocrel_base, 0, 1)) == TOC_REGISTER);
 }
 
 /* Return true if X is a constant pool address, and also for cmodel=medium
@@ -16453,16 +16455,44 @@
     case ALTIVEC_BUILTIN_VSLH:
     case ALTIVEC_BUILTIN_VSLW:
     case P8V_BUILTIN_VSLD:
-      arg0 = gimple_call_arg (stmt, 0);
-      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))
-	  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))
-	return false;
-      arg1 = gimple_call_arg (stmt, 1);
-      lhs = gimple_call_lhs (stmt);
-      g = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, arg1);
-      gimple_set_location (g, gimple_location (stmt));
-      gsi_replace (gsi, g, true);
-      return true;
+      {
+	location_t loc;
+	gimple_seq stmts = NULL;
+	arg0 = gimple_call_arg (stmt, 0);
+	tree arg0_type = TREE_TYPE (arg0);
+	if (INTEGRAL_TYPE_P (TREE_TYPE (arg0_type))
+	    && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0_type)))
+	  return false;
+	arg1 = gimple_call_arg (stmt, 1);
+	tree arg1_type = TREE_TYPE (arg1);
+	tree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));
+	tree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));
+	loc = gimple_location (stmt);
+	lhs = gimple_call_lhs (stmt);
+	/* Force arg1 into the range valid matching the arg0 type.  */
+	/* Build a vector consisting of the max valid bit-size values.  */
+	int n_elts = VECTOR_CST_NELTS (arg1);
+	int tree_size_in_bits = TREE_INT_CST_LOW (size_in_bytes (arg1_type))
+				* BITS_PER_UNIT;
+	tree element_size = build_int_cst (unsigned_element_type,
+					   tree_size_in_bits / n_elts);
+	tree_vector_builder elts (unsigned_type_for (arg1_type), n_elts, 1);
+	for (int i = 0; i < n_elts; i++)
+	  elts.safe_push (element_size);
+	tree modulo_tree = elts.build ();
+	/* Modulo the provided shift value against that vector.  */
+	tree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,
+					   unsigned_arg1_type, arg1);
+	tree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,
+				      unsigned_arg1_type, unsigned_arg1,
+				      modulo_tree);
+	gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);
+	/* And finally, do the shift.  */
+	g = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, new_arg1);
+	gimple_set_location (g, gimple_location (stmt));
+	gsi_replace (gsi, g, true);
+	return true;
+      }
     /* Flavors of vector shift right.  */
     case ALTIVEC_BUILTIN_VSRB:
     case ALTIVEC_BUILTIN_VSRH:
@@ -25226,6 +25256,12 @@
 {
   tree fntype;
 
+  /* The sibcall epilogue may clobber the static chain register.
+     ??? We could work harder and avoid that, but it's probably
+     not worth the hassle in practice.  */
+  if (CALL_EXPR_STATIC_CHAIN (exp))
+    return false;
+
   if (decl)
     fntype = TREE_TYPE (decl);
   else
diff -Naur gcc-8.2.0/gcc/config/rs6000/rs6000.md gcc-8-20181012/gcc/config/rs6000/rs6000.md
--- gcc-8.2.0/gcc/config/rs6000/rs6000.md	2018-06-25 14:40:14.000000000 +0300
+++ gcc-8-20181012/gcc/config/rs6000/rs6000.md	2018-09-28 00:31:04.000000000 +0300
@@ -1008,7 +1008,7 @@
 		     "=r, r,   wl,    wu,    wj,    wK,     wH,    wr")
 
 	(sign_extend:EXTSI (match_operand:SI 1 "lwa_operand"
-		     "Y,  r,   Z,     Z,     r,     wK,     wH,    ?wIwH")))]
+		     "YZ, r,   Z,     Z,     r,     wK,     wH,    ?wIwH")))]
   ""
   "@
    lwa%U1%X1 %0,%1
@@ -7433,8 +7433,8 @@
 ; ld/std require word-aligned displacements -> 'Y' constraint.
 ; List Y->r and r->Y before r->r for reload.
 (define_insn "*mov<mode>_hardfloat64"
-  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,<f64_p9>,wY,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,Y,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>")
-	(match_operand:FMOVE64 1 "input_operand" "d,m,d,wY,<f64_p9>,Z,<f64_av>,<f64_vsx>,<zero_fp>,<zero_fp>,r,Y,r,r,h,0,wg,r,<f64_dm>,r"))]
+  [(set (match_operand:FMOVE64 0 "nonimmediate_operand" "=m,d,d,<f64_p9>,wY,<f64_av>,Z,<f64_vsx>,<f64_vsx>,!r,YZ,r,!r,*c*l,!r,*h,r,wg,r,<f64_dm>")
+	(match_operand:FMOVE64 1 "input_operand" "d,m,d,wY,<f64_p9>,Z,<f64_av>,<f64_vsx>,<zero_fp>,<zero_fp>,r,YZ,r,r,h,0,wg,r,<f64_dm>,r"))]
   "TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT
    && (gpc_reg_operand (operands[0], <MODE>mode)
        || gpc_reg_operand (operands[1], <MODE>mode))"
diff -Naur gcc-8.2.0/gcc/config/rs6000/xmmintrin.h gcc-8-20181012/gcc/config/rs6000/xmmintrin.h
--- gcc-8.2.0/gcc/config/rs6000/xmmintrin.h	2018-04-03 22:06:28.000000000 +0300
+++ gcc-8-20181012/gcc/config/rs6000/xmmintrin.h	2018-09-14 18:43:35.000000000 +0300
@@ -57,6 +57,9 @@
 #ifndef _XMMINTRIN_H_INCLUDED
 #define _XMMINTRIN_H_INCLUDED
 
+/* Define four value permute mask */
+#define _MM_SHUFFLE(w,x,y,z) (((w) << 6) | ((x) << 4) | ((y) << 2) | (z))
+
 #include <altivec.h>
 
 /* Avoid collisions between altivec.h and strict adherence to C++ and
diff -Naur gcc-8.2.0/gcc/config/s390/s390.md gcc-8-20181012/gcc/config/s390/s390.md
--- gcc-8.2.0/gcc/config/s390/s390.md	2018-04-06 10:45:42.000000000 +0300
+++ gcc-8-20181012/gcc/config/s390/s390.md	2018-09-12 14:08:25.000000000 +0300
@@ -405,6 +405,10 @@
    ; Bitposition of operand types
    (PFPO_OP0_TYPE_SHIFT          16)
    (PFPO_OP1_TYPE_SHIFT           8)
+   ; Decide whether current DFP or BFD rounding mode should be used
+   ; for the conversion.
+   (PFPO_RND_MODE_DFP             0)
+   (PFPO_RND_MODE_BFP             1)
   ])
 
 ; Immediate operands for tbegin and tbeginc
@@ -5378,9 +5382,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_DFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -5400,9 +5408,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_BFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -5443,9 +5455,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_DFP);
 
   operands[2] = GEN_INT (flags);
 })
@@ -5465,9 +5481,13 @@
 {
   HOST_WIDE_INT flags;
 
+  /* According to IEEE 754 2008 4.3 'Rounding-direction attributes' the
+     rounding mode of the target format needs to be used.  */
+
   flags = (PFPO_CONVERT |
            PFPO_OP_TYPE_<BFP:MODE> << PFPO_OP0_TYPE_SHIFT |
-           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT);
+           PFPO_OP_TYPE_<DFP_ALL:MODE> << PFPO_OP1_TYPE_SHIFT |
+	   PFPO_RND_MODE_BFP);
 
   operands[2] = GEN_INT (flags);
 })
diff -Naur gcc-8.2.0/gcc/config/xtensa/xtensa.c gcc-8-20181012/gcc/config/xtensa/xtensa.c
--- gcc-8.2.0/gcc/config/xtensa/xtensa.c	2018-02-20 00:58:04.000000000 +0300
+++ gcc-8-20181012/gcc/config/xtensa/xtensa.c	2018-09-04 20:53:22.000000000 +0300
@@ -1614,9 +1614,9 @@
       break;
 
     case MULT: /* NAND */
-      tmp = expand_simple_binop (SImode, XOR, old, ac.modemask,
+      tmp = expand_simple_binop (SImode, AND, old, val,
 				 NULL_RTX, 1, OPTAB_DIRECT);
-      tmp = expand_simple_binop (SImode, AND, tmp, val,
+      tmp = expand_simple_binop (SImode, XOR, tmp, ac.modemask,
 				 new_rtx, 1, OPTAB_DIRECT);
       break;
 
diff -Naur gcc-8.2.0/gcc/coverage.c gcc-8-20181012/gcc/coverage.c
--- gcc-8.2.0/gcc/coverage.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/coverage.c	2018-10-03 12:24:38.000000000 +0300
@@ -663,7 +663,8 @@
   gcov_write_unsigned (cfg_checksum);
   gcov_write_string (IDENTIFIER_POINTER
 		     (DECL_ASSEMBLER_NAME (current_function_decl)));
-  gcov_write_unsigned (DECL_ARTIFICIAL (current_function_decl));
+  gcov_write_unsigned (DECL_ARTIFICIAL (current_function_decl)
+		       && !DECL_LAMBDA_FUNCTION (current_function_decl));
   gcov_write_filename (xloc.file);
   gcov_write_unsigned (xloc.line);
   gcov_write_unsigned (xloc.column);
diff -Naur gcc-8.2.0/gcc/cp/ChangeLog gcc-8-20181012/gcc/cp/ChangeLog
--- gcc-8.2.0/gcc/cp/ChangeLog	2018-07-26 12:47:20.000000000 +0300
+++ gcc-8-20181012/gcc/cp/ChangeLog	2018-10-11 20:42:29.000000000 +0300
@@ -1,3 +1,127 @@
+2018-10-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87582
+	* typeck.c (maybe_warn_about_returning_address_of_local): If
+	whats_returned is a structured binding identifier and the structured
+	binding is a reference, recurse on its initializer.
+
+2018-10-10  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/84940
+	* semantics.c (finish_unary_op_expr): Check return value of
+	build_x_unary_op for error_mark_node.
+
+2018-10-03  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-10-03  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/86109
+	* parser.c (cp_parser_lambda_declarator_opt):
+	Set DECL_LAMBDA_FUNCTION for lambdas.
+
+2018-09-24  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/85070
+	* method.c (lazily_declare_fn): During error-recovery add_method
+	may return false.
+
+2018-09-18  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/86881
+	* name-lookup.c (check_local_shadow): Ignore auto types.
+
+2018-09-13  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-09-13  Ville Voutilainen  <ville.voutilainen@gmail.com>
+	gcc/cp
+
+	PR c++/87093
+	* method.c (constructible_expr): We're in an unevaluated context
+	in all cases, not just for class targets.
+
+	testsuite/
+
+	PR c++/87093
+	* g++.dg/ext/is_constructible2.C: New.
+
+2018-09-05   Pádraig Brady  <p@draigbrady.com>
+
+	PR c++/87185
+	* lambda.c (prune_lambda_captures): Protect against const_vars.get
+	returning NULL.
+
+2018-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87095
+	* decl.c (begin_destructor_body): If current_class_type has
+	virtual bases and the primary base is nearly empty virtual base,
+	voidify clearing of vptr and make it conditional on in-charge
+	argument.
+
+	2018-08-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86836
+	* pt.c (tsubst_expr): For structured bindings, call tsubst_decomp_names
+	before tsubst_init, not after it.
+
+	PR c++/86738
+	* constexpr.c (cxx_eval_binary_expression): For arithmetics involving
+	NULL pointer set *non_constant_p to true.
+	(cxx_eval_component_reference): For dereferencing of a NULL pointer,
+	set *non_constant_p to true and return t.
+
+	2018-08-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86706
+	* class.c (build_base_path): Use currently_open_class.
+
+2018-08-31  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/87155
+	PR c++/84707
+	* name-lookup.c (name_lookup::search_namespace): Don't look at
+	inlines when searching for NULL names.
+
+2018-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87122
+	* pt.c (tsubst_expr) <case RANGE_FOR_STMT>: If
+	processing_template_decl and decl is structured binding decl, call
+	cp_finish_decomp.
+
+2018-08-17  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-08-02  Richard Biener  <rguenther@suse.de>
+
+	PR c++/86763
+	* class.c (layout_class_type): Copy TYPE_TYPELESS_STORAGE
+	to the CLASSTYPE_AS_BASE.
+
+2018-08-10  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86728 - C variadic generic lambda.
+	* parser.c (cp_parser_parameter_declaration): Don't turn 'auto' into
+	a pack if it's followed by a declarator-id.
+
+2018-08-08  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2018-08-06  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/86767
+	* constexpr.c (cxx_eval_statement_list): Handle continue.
+
+2018-08-01  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/86190 - bogus -Wsign-conversion warning
+	* typeck.c (cp_build_binary_op): Add a warning sentinel.
+
 2018-07-26  Release Manager
 
 	* GCC 8.2.0 released.
diff -Naur gcc-8.2.0/gcc/cp/class.c gcc-8-20181012/gcc/cp/class.c
--- gcc-8.2.0/gcc/cp/class.c	2018-06-13 22:39:53.000000000 +0300
+++ gcc-8-20181012/gcc/cp/class.c	2018-09-05 10:16:15.000000000 +0300
@@ -278,6 +278,9 @@
   probe = TYPE_MAIN_VARIANT (TREE_TYPE (expr));
   if (want_pointer)
     probe = TYPE_MAIN_VARIANT (TREE_TYPE (probe));
+  if (dependent_type_p (probe))
+    if (tree open = currently_open_class (probe))
+      probe = open;
 
   if (code == PLUS_EXPR
       && !SAME_BINFO_TYPE_P (BINFO_TYPE (d_binfo), probe))
@@ -6243,6 +6246,7 @@
 				  bitsize_int (BITS_PER_UNIT)));
       SET_TYPE_ALIGN (base_t, rli->record_align);
       TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);
+      TYPE_TYPELESS_STORAGE (base_t) = TYPE_TYPELESS_STORAGE (t);
 
       /* Copy the non-static data members of T. This will include its
 	 direct non-virtual bases & vtable.  */
diff -Naur gcc-8.2.0/gcc/cp/constexpr.c gcc-8-20181012/gcc/cp/constexpr.c
--- gcc-8.2.0/gcc/cp/constexpr.c	2018-06-23 00:57:32.000000000 +0300
+++ gcc-8-20181012/gcc/cp/constexpr.c	2018-09-05 10:19:27.000000000 +0300
@@ -2066,6 +2066,7 @@
     {
       if (!ctx->quiet)
 	error ("arithmetic involving a null pointer in %qE", lhs);
+      *non_constant_p = true;
       return t;
     }
   else if (code == POINTER_PLUS_EXPR)
@@ -2506,9 +2507,13 @@
 					     lval,
 					     non_constant_p, overflow_p);
   if (INDIRECT_REF_P (whole)
-      && integer_zerop (TREE_OPERAND (whole, 0))
-      && !ctx->quiet)
-    error ("dereferencing a null pointer in %qE", orig_whole);
+      && integer_zerop (TREE_OPERAND (whole, 0)))
+    {
+      if (!ctx->quiet)
+	error ("dereferencing a null pointer in %qE", orig_whole);
+      *non_constant_p = true;
+      return t;
+    }
 
   if (TREE_CODE (whole) == PTRMEM_CST)
     whole = cplus_expand_constant (whole);
@@ -3926,6 +3931,16 @@
   for (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))
     {
       tree stmt = tsi_stmt (i);
+      /* We've found a continue, so skip everything until we reach
+	 the label its jumping to.  */
+      if (continues (jump_target))
+	{
+	  if (label_matches (ctx, jump_target, stmt))
+	    /* Found it.  */
+	    *jump_target = NULL_TREE;
+	  else
+	    continue;
+	}
       if (TREE_CODE (stmt) == DEBUG_BEGIN_STMT)
 	continue;
       r = cxx_eval_constant_expression (ctx, stmt, false,
diff -Naur gcc-8.2.0/gcc/cp/decl.c gcc-8-20181012/gcc/cp/decl.c
--- gcc-8.2.0/gcc/cp/decl.c	2018-07-12 22:37:11.000000000 +0300
+++ gcc-8-20181012/gcc/cp/decl.c	2018-09-05 10:22:07.000000000 +0300
@@ -15557,6 +15557,18 @@
 	    tree stmt = cp_build_modify_expr (input_location, vtbl_ptr,
 					      NOP_EXPR, vtbl,
 					      tf_warning_or_error);
+	    /* If the vptr is shared with some virtual nearly empty base,
+	       don't clear it if not in charge, the dtor of the virtual
+	       nearly empty base will do that later.  */
+	    if (CLASSTYPE_VBASECLASSES (current_class_type)
+		&& CLASSTYPE_PRIMARY_BINFO (current_class_type)
+		&& BINFO_VIRTUAL_P
+			  (CLASSTYPE_PRIMARY_BINFO (current_class_type)))
+	      {
+		stmt = convert_to_void (stmt, ICV_STATEMENT,
+					tf_warning_or_error);
+		stmt = build_if_in_charge (stmt);
+	      }
 	    finish_decl_cleanup (NULL_TREE, stmt);
 	  }
 	else
diff -Naur gcc-8.2.0/gcc/cp/lambda.c gcc-8-20181012/gcc/cp/lambda.c
--- gcc-8.2.0/gcc/cp/lambda.c	2018-06-15 23:23:13.000000000 +0300
+++ gcc-8-20181012/gcc/cp/lambda.c	2018-09-05 20:32:26.000000000 +0300
@@ -1511,8 +1511,8 @@
       tree cap = *capp;
       if (tree var = var_to_maybe_prune (cap))
 	{
-	  tree *use = *const_vars.get (var);
-	  if (TREE_CODE (*use) == DECL_EXPR)
+	  tree **use = const_vars.get (var);
+	  if (use && TREE_CODE (**use) == DECL_EXPR)
 	    {
 	      /* All uses of this capture were folded away, leaving only the
 		 proxy declaration.  */
@@ -1527,7 +1527,7 @@
 	      *fieldp = DECL_CHAIN (*fieldp);
 
 	      /* And remove the capture proxy declaration.  */
-	      *use = void_node;
+	      **use = void_node;
 	      continue;
 	    }
 	}
diff -Naur gcc-8.2.0/gcc/cp/method.c gcc-8-20181012/gcc/cp/method.c
--- gcc-8.2.0/gcc/cp/method.c	2018-07-04 23:56:12.000000000 +0300
+++ gcc-8-20181012/gcc/cp/method.c	2018-09-24 20:44:02.000000000 +0300
@@ -1144,11 +1144,11 @@
 constructible_expr (tree to, tree from)
 {
   tree expr;
+  cp_unevaluated cp_uneval_guard;
   if (CLASS_TYPE_P (to))
     {
       tree ctype = to;
       vec<tree, va_gc> *args = NULL;
-      cp_unevaluated cp_uneval_guard;
       if (TREE_CODE (to) != REFERENCE_TYPE)
 	to = cp_build_reference_type (to, /*rval*/false);
       tree ob = build_stub_object (to);
@@ -2405,7 +2405,7 @@
 
   /* Add it to the class  */
   bool added = add_method (type, fn, false);
-  gcc_assert (added);
+  gcc_assert (added || errorcount);
 
   /* Add it to TYPE_FIELDS.  */
   if (sfk == sfk_destructor
diff -Naur gcc-8.2.0/gcc/cp/name-lookup.c gcc-8-20181012/gcc/cp/name-lookup.c
--- gcc-8.2.0/gcc/cp/name-lookup.c	2018-07-03 19:25:49.000000000 +0300
+++ gcc-8-20181012/gcc/cp/name-lookup.c	2018-09-18 18:06:35.000000000 +0300
@@ -560,11 +560,14 @@
 
   /* Look in exactly namespace. */
   bool found = search_namespace_only (scope);
-  
-  /* Recursively look in its inline children.  */
-  if (vec<tree, va_gc> *inlinees = DECL_NAMESPACE_INLINEES (scope))
-    for (unsigned ix = inlinees->length (); ix--;)
-      found |= search_namespace ((*inlinees)[ix]);
+
+  /* Don't look into inline children, if we're looking for an
+     anonymous name -- it must be in the current scope, if anywhere.  */
+  if (name)
+    /* Recursively look in its inline children.  */
+    if (vec<tree, va_gc> *inlinees = DECL_NAMESPACE_INLINEES (scope))
+      for (unsigned ix = inlinees->length (); ix--;)
+	found |= search_namespace ((*inlinees)[ix]);
 
   if (found)
     mark_found (scope);
@@ -2737,6 +2740,13 @@
 	       && (same_type_p (TREE_TYPE (old), TREE_TYPE (decl))
 		   || (!dependent_type_p (TREE_TYPE (decl))
 		       && !dependent_type_p (TREE_TYPE (old))
+		       /* If the new decl uses auto, we don't yet know
+			  its type (the old type cannot be using auto
+			  at this point, without also being
+			  dependent).  This is an indication we're
+			  (now) doing the shadow checking too
+			  early.  */
+		       && !type_uses_auto (TREE_TYPE (decl))
 		       && can_convert (TREE_TYPE (old), TREE_TYPE (decl),
 				       tf_none))))
 	warning_code = OPT_Wshadow_compatible_local;
diff -Naur gcc-8.2.0/gcc/cp/parser.c gcc-8-20181012/gcc/cp/parser.c
--- gcc-8.2.0/gcc/cp/parser.c	2018-06-26 13:44:52.000000000 +0300
+++ gcc-8-20181012/gcc/cp/parser.c	2018-10-03 12:24:38.000000000 +0300
@@ -10620,6 +10620,7 @@
 	DECL_ARTIFICIAL (fco) = 1;
 	/* Give the object parameter a different name.  */
 	DECL_NAME (DECL_ARGUMENTS (fco)) = get_identifier ("__closure");
+	DECL_LAMBDA_FUNCTION (fco) = 1;
 	if (return_type)
 	  TYPE_HAS_LATE_RETURN_TYPE (TREE_TYPE (fco)) = 1;
       }
@@ -21598,7 +21599,8 @@
      parameter was introduced during cp_parser_parameter_declaration,
      change any implicit parameters introduced into packs.  */
   if (parser->implicit_template_parms
-      && (token->type == CPP_ELLIPSIS
+      && ((token->type == CPP_ELLIPSIS
+	   && declarator_can_be_parameter_pack (declarator))
 	  || (declarator && declarator->parameter_pack_p)))
     {
       int latest_template_parm_idx = TREE_VEC_LENGTH
diff -Naur gcc-8.2.0/gcc/cp/pt.c gcc-8-20181012/gcc/cp/pt.c
--- gcc-8.2.0/gcc/cp/pt.c	2018-07-18 16:42:02.000000000 +0300
+++ gcc-8-20181012/gcc/cp/pt.c	2018-09-05 10:20:31.000000000 +0300
@@ -16734,7 +16734,17 @@
 		else
 		  {
 		    int const_init = false;
+		    unsigned int cnt = 0;
+		    tree first = NULL_TREE, ndecl = error_mark_node;
 		    maybe_push_decl (decl);
+
+		    if (VAR_P (decl)
+			&& DECL_DECOMPOSITION_P (decl)
+			&& TREE_TYPE (pattern_decl) != error_mark_node)
+		      ndecl = tsubst_decomp_names (decl, pattern_decl, args,
+						   complain, in_decl, &first,
+						   &cnt);
+
 		    if (VAR_P (decl)
 			&& DECL_PRETTY_FUNCTION_P (decl))
 		      {
@@ -16750,23 +16760,14 @@
 		    if (VAR_P (decl))
 		      const_init = (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
 				    (pattern_decl));
-		    if (VAR_P (decl)
-			&& DECL_DECOMPOSITION_P (decl)
-			&& TREE_TYPE (pattern_decl) != error_mark_node)
-		      {
-			unsigned int cnt;
-			tree first;
-			tree ndecl
-			  = tsubst_decomp_names (decl, pattern_decl, args,
-						 complain, in_decl, &first, &cnt);
-			if (ndecl != error_mark_node)
-			  cp_maybe_mangle_decomp (ndecl, first, cnt);
-			cp_finish_decl (decl, init, const_init, NULL_TREE, 0);
-			if (ndecl != error_mark_node)
-			  cp_finish_decomp (ndecl, first, cnt);
-		      }
-		    else
-		      cp_finish_decl (decl, init, const_init, NULL_TREE, 0);
+
+		    if (ndecl != error_mark_node)
+		      cp_maybe_mangle_decomp (ndecl, first, cnt);
+
+		    cp_finish_decl (decl, init, const_init, NULL_TREE, 0);
+
+		    if (ndecl != error_mark_node)
+		      cp_finish_decomp (ndecl, first, cnt);
 		  }
 	      }
 	  }
@@ -16816,6 +16817,8 @@
 	    RANGE_FOR_IVDEP (stmt) = RANGE_FOR_IVDEP (t);
 	    RANGE_FOR_UNROLL (stmt) = RANGE_FOR_UNROLL (t);
 	    finish_range_for_decl (stmt, decl, expr);
+	    if (decomp_first && decl != error_mark_node)
+	      cp_finish_decomp (decl, decomp_first, decomp_cnt);
 	  }
 	else
 	  {
diff -Naur gcc-8.2.0/gcc/cp/semantics.c gcc-8-20181012/gcc/cp/semantics.c
--- gcc-8.2.0/gcc/cp/semantics.c	2018-06-05 14:27:15.000000000 +0300
+++ gcc-8-20181012/gcc/cp/semantics.c	2018-10-10 11:16:37.000000000 +0300
@@ -2704,13 +2704,14 @@
   /* TODO: build_x_unary_op doesn't always honor the location.  */
   result.set_location (combined_loc);
 
-  tree result_ovl, expr_ovl;
+  if (result == error_mark_node)
+    return result;
 
   if (!(complain & tf_warning))
     return result;
 
-  result_ovl = result;
-  expr_ovl = expr;
+  tree result_ovl = result;
+  tree expr_ovl = expr;
 
   if (!processing_template_decl)
     expr_ovl = cp_fully_fold (expr_ovl);
diff -Naur gcc-8.2.0/gcc/cp/typeck.c gcc-8-20181012/gcc/cp/typeck.c
--- gcc-8.2.0/gcc/cp/typeck.c	2018-04-27 18:06:14.000000000 +0300
+++ gcc-8-20181012/gcc/cp/typeck.c	2018-10-11 20:42:29.000000000 +0300
@@ -5353,6 +5353,7 @@
      otherwise, it will be given type RESULT_TYPE.  */
   if (! converted)
     {
+      warning_sentinel w (warn_sign_conversion, short_compare);
       if (TREE_TYPE (op0) != result_type)
 	op0 = cp_convert_and_check (result_type, op0, complain);
       if (TREE_TYPE (op1) != result_type)
@@ -9066,6 +9067,22 @@
       && !(TREE_STATIC (whats_returned)
 	   || TREE_PUBLIC (whats_returned)))
     {
+      if (VAR_P (whats_returned)
+	  && DECL_DECOMPOSITION_P (whats_returned)
+	  && DECL_DECOMP_BASE (whats_returned)
+	  && DECL_HAS_VALUE_EXPR_P (whats_returned))
+	{
+	  /* When returning address of a structured binding, if the structured
+	     binding is not a reference, continue normally, if it is a
+	     reference, recurse on the initializer of the structured
+	     binding.  */
+	  tree base = DECL_DECOMP_BASE (whats_returned);
+	  if (TREE_CODE (TREE_TYPE (base)) == REFERENCE_TYPE)
+	    {
+	      tree init = DECL_INITIAL (base);
+	      return maybe_warn_about_returning_address_of_local (init);
+	    }
+	}
       if (TREE_CODE (valtype) == REFERENCE_TYPE)
 	warning_at (DECL_SOURCE_LOCATION (whats_returned),
 		    OPT_Wreturn_local_addr,
diff -Naur gcc-8.2.0/gcc/DATESTAMP gcc-8-20181012/gcc/DATESTAMP
--- gcc-8.2.0/gcc/DATESTAMP	2018-07-26 03:16:24.000000000 +0300
+++ gcc-8-20181012/gcc/DATESTAMP	2018-10-12 03:16:42.000000000 +0300
@@ -1 +1 @@
-20180726
+20181012
diff -Naur gcc-8.2.0/gcc/defaults.h gcc-8-20181012/gcc/defaults.h
--- gcc-8.2.0/gcc/defaults.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/defaults.h	2018-08-01 09:53:34.000000000 +0300
@@ -1282,6 +1282,10 @@
 #define TARGET_PECOFF 0
 #endif
 
+#ifndef TARGET_COFF
+#define TARGET_COFF 0
+#endif
+
 #ifndef EH_RETURN_HANDLER_RTX
 #define EH_RETURN_HANDLER_RTX NULL
 #endif
diff -Naur gcc-8.2.0/gcc/dojump.c gcc-8-20181012/gcc/dojump.c
--- gcc-8.2.0/gcc/dojump.c	2018-01-23 01:59:33.000000000 +0300
+++ gcc-8-20181012/gcc/dojump.c	2018-09-15 02:30:32.000000000 +0300
@@ -1214,15 +1214,15 @@
   code = unsignedp ? unsigned_code : signed_code;
 
   /* If function pointers need to be "canonicalized" before they can
-     be reliably compared, then canonicalize them.
-     Only do this if *both* sides of the comparison are function pointers.
-     If one side isn't, we want a noncanonicalized comparison.  See PR
-     middle-end/17564.  */
+     be reliably compared, then canonicalize them.  Canonicalize the
+     expression when one of the operands is a function pointer.  This
+     handles the case where the other operand is a void pointer.  See
+     PR middle-end/17564.  */
   if (targetm.have_canonicalize_funcptr_for_compare ()
-      && POINTER_TYPE_P (TREE_TYPE (treeop0))
-      && POINTER_TYPE_P (TREE_TYPE (treeop1))
-      && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (treeop0)))
-      && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (treeop1))))
+      && ((POINTER_TYPE_P (TREE_TYPE (treeop0))
+	   && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (treeop0))))
+	  || (POINTER_TYPE_P (TREE_TYPE (treeop1))
+	      && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (treeop1))))))
     {
       rtx new_op0 = gen_reg_rtx (mode);
       rtx new_op1 = gen_reg_rtx (mode);
diff -Naur gcc-8.2.0/gcc/dwarf2out.c gcc-8-20181012/gcc/dwarf2out.c
--- gcc-8.2.0/gcc/dwarf2out.c	2018-07-16 14:57:10.000000000 +0300
+++ gcc-8-20181012/gcc/dwarf2out.c	2018-08-31 11:33:14.000000000 +0300
@@ -28472,7 +28472,7 @@
       debug_str_section = get_section (DEBUG_LTO_STR_SECTION,
 				       DEBUG_STR_SECTION_FLAGS
 				       | SECTION_EXCLUDE, NULL);
-      if (!dwarf_split_debug_info && !output_asm_line_debug_info ())
+      if (!dwarf_split_debug_info)
 	debug_line_str_section
 	  = get_section (DEBUG_LTO_LINE_STR_SECTION,
 			 DEBUG_STR_SECTION_FLAGS | SECTION_EXCLUDE, NULL);
@@ -31074,6 +31074,11 @@
 
       /* Remove indirect string decisions.  */
       debug_str_hash->traverse<void *, reset_indirect_string> (NULL);
+      if (debug_line_str_hash)
+	{
+	  debug_line_str_hash->traverse<void *, reset_indirect_string> (NULL);
+	  debug_line_str_hash = NULL;
+	}
     }
 
 #if ENABLE_ASSERT_CHECKING
@@ -31330,8 +31335,8 @@
       switch_to_section (debug_loc_section);
       if (dwarf_version >= 5)
 	{
-	  ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_LOC_SECTION_LABEL, 1);
-	  ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_LOC_SECTION_LABEL, 2);
+	  ASM_GENERATE_INTERNAL_LABEL (l1, DEBUG_LOC_SECTION_LABEL, 2);
+	  ASM_GENERATE_INTERNAL_LABEL (l2, DEBUG_LOC_SECTION_LABEL, 3);
 	  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)
 	    dw2_asm_output_data (4, 0xffffffff,
 				 "Initial length escape value indicating "
@@ -31832,10 +31837,10 @@
 
   /* Do not generate DWARF assembler now when not producing LTO bytecode.  */
   if ((!flag_generate_lto && !flag_generate_offload)
-      /* FIXME: Disable debug info generation for PE-COFF targets since the
+      /* FIXME: Disable debug info generation for (PE-)COFF targets since the
 	 copy_lto_debug_sections operation of the simple object support in
 	 libiberty is not implemented for them yet.  */
-      || TARGET_PECOFF)
+      || TARGET_PECOFF || TARGET_COFF)
     return;
 
   /* Now as we are going to output for LTO initialize sections and labels
@@ -31950,6 +31955,13 @@
   /* If we emitted any indirect strings, output the string table too.  */
   if (debug_str_hash || skeleton_debug_str_hash)
     output_indirect_strings ();
+  if (debug_line_str_hash)
+    {
+      switch_to_section (debug_line_str_section);
+      const enum dwarf_form form = DW_FORM_line_strp;
+      debug_line_str_hash->traverse<enum dwarf_form,
+				    output_indirect_string> (form);
+    }
 
   /* Switch back to the text section.  */
   switch_to_section (text_section);
diff -Naur gcc-8.2.0/gcc/expmed.c gcc-8-20181012/gcc/expmed.c
--- gcc-8.2.0/gcc/expmed.c	2018-01-15 17:43:52.000000000 +0300
+++ gcc-8-20181012/gcc/expmed.c	2018-09-05 10:23:00.000000000 +0300
@@ -3343,19 +3343,21 @@
 	  /* Write a REG_EQUAL note on the last insn so that we can cse
 	     multiplication sequences.  Note that if ACCUM is a SUBREG,
 	     we've set the inner register and must properly indicate that.  */
-          tem = op0, nmode = mode;
-          accum_inner = accum;
-          if (GET_CODE (accum) == SUBREG)
+	  tem = op0, nmode = mode;
+	  accum_inner = accum;
+	  if (GET_CODE (accum) == SUBREG)
 	    {
 	      accum_inner = SUBREG_REG (accum);
 	      nmode = GET_MODE (accum_inner);
 	      tem = gen_lowpart (nmode, op0);
 	    }
 
-          insn = get_last_insn ();
-          set_dst_reg_note (insn, REG_EQUAL,
-			    gen_rtx_MULT (nmode, tem,
-					  gen_int_mode (val_so_far, nmode)),
+	  insn = get_last_insn ();
+	  wide_int wval_so_far
+	    = wi::uhwi (val_so_far,
+			GET_MODE_PRECISION (as_a <scalar_mode> (nmode)));
+	  rtx c = immed_wide_int_const (wval_so_far, nmode);
+	  set_dst_reg_note (insn, REG_EQUAL, gen_rtx_MULT (nmode, tem, c),
 			    accum_inner);
 	}
     }
@@ -4480,6 +4482,11 @@
 		HOST_WIDE_INT d = INTVAL (op1);
 		unsigned HOST_WIDE_INT abs_d;
 
+		/* Not prepared to handle division/remainder by
+		   0xffffffffffffffff8000000000000000 etc.  */
+		if (d == HOST_WIDE_INT_MIN && size > HOST_BITS_PER_WIDE_INT)
+		  break;
+
 		/* Since d might be INT_MIN, we have to cast to
 		   unsigned HOST_WIDE_INT before negating to avoid
 		   undefined signed overflow.  */
@@ -4522,9 +4529,7 @@
 			     || (optab_handler (sdivmod_optab, int_mode)
 				 != CODE_FOR_nothing)))
 		  ;
-		else if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d)
-			 && (size <= HOST_BITS_PER_WIDE_INT
-			     || abs_d != (unsigned HOST_WIDE_INT) d))
+		else if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))
 		  {
 		    if (rem_flag)
 		      {
@@ -6038,6 +6043,11 @@
       if (!HAVE_conditional_move)
 	return 0;
 
+      /* Do not turn a trapping comparison into a non-trapping one.  */
+      if ((code != EQ && code != NE && code != UNEQ && code != LTGT)
+	  && flag_trapping_math)
+	return 0;
+
       /* Try using a setcc instruction for ORDERED/UNORDERED, followed by a
 	 conditional move.  */
       tem = emit_store_flag_1 (subtarget, first_code, op0, op1, mode, 0,
diff -Naur gcc-8.2.0/gcc/expr.c gcc-8-20181012/gcc/expr.c
--- gcc-8.2.0/gcc/expr.c	2018-06-15 23:37:46.000000000 +0300
+++ gcc-8-20181012/gcc/expr.c	2018-09-15 02:30:32.000000000 +0300
@@ -11532,12 +11532,10 @@
   /* We won't bother with store-flag operations involving function pointers
      when function pointers must be canonicalized before comparisons.  */
   if (targetm.have_canonicalize_funcptr_for_compare ()
-      && ((TREE_CODE (TREE_TYPE (arg0)) == POINTER_TYPE
-	   && (TREE_CODE (TREE_TYPE (TREE_TYPE (arg0)))
-	       == FUNCTION_TYPE))
-	  || (TREE_CODE (TREE_TYPE (arg1)) == POINTER_TYPE
-	      && (TREE_CODE (TREE_TYPE (TREE_TYPE (arg1)))
-		  == FUNCTION_TYPE))))
+      && ((POINTER_TYPE_P (TREE_TYPE (arg0))
+	   && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (arg0))))
+	  || (POINTER_TYPE_P (TREE_TYPE (arg1))
+	      && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (arg1))))))
     return 0;
 
   STRIP_NOPS (arg0);
diff -Naur gcc-8.2.0/gcc/fold-const.c gcc-8-20181012/gcc/fold-const.c
--- gcc-8.2.0/gcc/fold-const.c	2018-05-08 16:33:54.000000000 +0300
+++ gcc-8-20181012/gcc/fold-const.c	2018-09-15 02:30:32.000000000 +0300
@@ -4922,8 +4922,8 @@
   /* Disable this optimization for function pointer expressions
      on targets that require function pointer canonicalization.  */
   if (targetm.have_canonicalize_funcptr_for_compare ()
-      && TREE_CODE (etype) == POINTER_TYPE
-      && TREE_CODE (TREE_TYPE (etype)) == FUNCTION_TYPE)
+      && POINTER_TYPE_P (etype)
+      && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (etype)))
     return NULL_TREE;
 
   if (! in_p)
@@ -11565,10 +11565,16 @@
 	  && integer_pow2p (arg1)
 	  && TREE_CODE (TREE_OPERAND (arg0, 0)) == BIT_AND_EXPR
 	  && operand_equal_p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1),
-			      arg1, OEP_ONLY_CONST))
+			      arg1, OEP_ONLY_CONST)
+	  /* operand_equal_p compares just value, not precision, so e.g.
+	     arg1 could be 8-bit -128 and be power of two, but BIT_AND_EXPR
+	     second operand 32-bit -128, which is not a power of two (or vice
+	     versa.  */
+	  && integer_pow2p (TREE_OPERAND (TREE_OPERAND (arg0, 0), 1)))
 	return pedantic_non_lvalue_loc (loc,
-				    fold_convert_loc (loc, type,
-						      TREE_OPERAND (arg0, 0)));
+					fold_convert_loc (loc, type,
+							  TREE_OPERAND (arg0,
+									0)));
 
       /* Disable the transformations below for vectors, since
 	 fold_binary_op_with_conditional_arg may undo them immediately,
diff -Naur gcc-8.2.0/gcc/fortran/arith.c gcc-8-20181012/gcc/fortran/arith.c
--- gcc-8.2.0/gcc/fortran/arith.c	2018-03-10 21:34:12.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/arith.c	2018-10-07 01:41:06.000000000 +0300
@@ -113,6 +113,11 @@
       p =
 	_("Integer outside symmetric range implied by Standard Fortran at %L");
       break;
+    case ARITH_WRONGCONCAT:
+      p =
+	_("Illegal type in character concatenation at %L");
+      break;
+
     default:
       gfc_internal_error ("gfc_arith_error(): Bad error code");
     }
@@ -982,7 +987,12 @@
   gfc_expr *result;
   size_t len;
 
-  gcc_assert (op1->ts.kind == op2->ts.kind);
+  /* By cleverly playing around with constructors, is is possible
+     to get mismaching types here.  */
+  if (op1->ts.type != BT_CHARACTER || op2->ts.type != BT_CHARACTER
+      || op1->ts.kind != op2->ts.kind)
+    return ARITH_WRONGCONCAT;
+
   result = gfc_get_constant_expr (BT_CHARACTER, op1->ts.kind,
 				  &op1->where);
 
diff -Naur gcc-8.2.0/gcc/fortran/decl.c gcc-8-20181012/gcc/fortran/decl.c
--- gcc-8.2.0/gcc/fortran/decl.c	2018-07-16 22:10:39.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/decl.c	2018-09-18 22:50:17.000000000 +0300
@@ -10557,7 +10557,8 @@
 
 done:
   if (ba->access == ACCESS_UNKNOWN)
-    ba->access = gfc_typebound_default_access;
+    ba->access = ppc ? gfc_current_block()->component_access
+                     : gfc_typebound_default_access;
 
   if (ppc && !seen_ptr)
     {
diff -Naur gcc-8.2.0/gcc/fortran/expr.c gcc-8-20181012/gcc/fortran/expr.c
--- gcc-8.2.0/gcc/fortran/expr.c	2018-07-16 21:59:44.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/expr.c	2018-09-18 22:16:24.000000000 +0300
@@ -1069,6 +1069,7 @@
 
   if (e->symtree->n.sym->ts.type == BT_CLASS
       && e->symtree->n.sym->attr.dummy
+      && CLASS_DATA (e->symtree->n.sym)->attr.dimension
       && CLASS_DATA (e->symtree->n.sym)->attr.class_pointer)
     return true;
 
@@ -5360,16 +5361,13 @@
 	return expr->value.function.esym->result->attr.contiguous;
       else
 	{
-	  /* We have to jump through some hoops if this is a vtab entry.  */
-	  gfc_symbol *s;
-	  gfc_ref *r, *rc;
-
-	  s = expr->symtree->n.sym;
-	  if (s->ts.type != BT_CLASS)
+	  /* Type-bound procedures.  */
+	  gfc_symbol *s = expr->symtree->n.sym;
+	  if (s->ts.type != BT_CLASS && s->ts.type != BT_DERIVED)
 	    return false;
-	  
-	  rc = NULL;
-	  for (r = expr->ref; r; r = r->next)
+
+	  gfc_ref *rc = NULL;
+	  for (gfc_ref *r = expr->ref; r; r = r->next)
 	    if (r->type == REF_COMPONENT)
 	      rc = r;
 
diff -Naur gcc-8.2.0/gcc/fortran/frontend-passes.c gcc-8-20181012/gcc/fortran/frontend-passes.c
--- gcc-8.2.0/gcc/fortran/frontend-passes.c	2018-06-07 20:33:44.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/frontend-passes.c	2018-08-25 01:08:48.000000000 +0300
@@ -1099,6 +1099,31 @@
   return 0;
 }
 
+/* Callback function to var_in_expr - return true if expr1 and
+   expr2 are identical variables. */
+static int
+var_in_expr_callback (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,
+		      void *data)
+{
+  gfc_expr *expr1 = (gfc_expr *) data;
+  gfc_expr *expr2 = *e;
+
+  if (expr2->expr_type != EXPR_VARIABLE)
+    return 0;
+
+  return expr1->symtree->n.sym == expr2->symtree->n.sym;
+}
+
+/* Return true if expr1 is found in expr2. */
+
+static bool
+var_in_expr (gfc_expr *expr1, gfc_expr *expr2)
+{
+  gcc_assert (expr1->expr_type == EXPR_VARIABLE);
+
+  return gfc_expr_walker (&expr2, var_in_expr_callback, (void *) expr1);
+}
+
 struct do_stack
 {
   struct do_stack *prev;
@@ -1251,9 +1276,9 @@
 	  for (int j = i - 1; j < i; j++)
 	    {
 	      if (iters[j]
-		  && (gfc_check_dependency (var, iters[j]->start, true)
-		      || gfc_check_dependency (var, iters[j]->end, true)
-		      || gfc_check_dependency (var, iters[j]->step, true)))
+		  && (var_in_expr (var, iters[j]->start)
+		      || var_in_expr (var, iters[j]->end)
+		      || var_in_expr (var, iters[j]->step)))
 		  return false;
 	    }		  
 	}
diff -Naur gcc-8.2.0/gcc/fortran/gfortran.h gcc-8-20181012/gcc/fortran/gfortran.h
--- gcc-8.2.0/gcc/fortran/gfortran.h	2018-03-28 14:59:06.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/gfortran.h	2018-10-07 01:41:06.000000000 +0300
@@ -191,7 +191,8 @@
 /* Arithmetic results.  */
 enum arith
 { ARITH_OK = 1, ARITH_OVERFLOW, ARITH_UNDERFLOW, ARITH_NAN,
-  ARITH_DIV0, ARITH_INCOMMENSURATE, ARITH_ASYMMETRIC, ARITH_PROHIBIT
+  ARITH_DIV0, ARITH_INCOMMENSURATE, ARITH_ASYMMETRIC, ARITH_PROHIBIT,
+  ARITH_WRONGCONCAT
 };
 
 /* Statements.  */
diff -Naur gcc-8.2.0/gcc/fortran/interface.c gcc-8-20181012/gcc/fortran/interface.c
--- gcc-8.2.0/gcc/fortran/interface.c	2018-03-21 04:07:43.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/interface.c	2018-09-05 22:22:53.000000000 +0300
@@ -735,13 +735,20 @@
   if (s2->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))
     return true;
 
+  return gfc_compare_types (&s1->ts, &s2->ts) || s2->ts.type == BT_ASSUMED;
+}
+
+
+static bool
+compare_type_characteristics (gfc_symbol *s1, gfc_symbol *s2)
+{
   /* TYPE and CLASS of the same declared type are type compatible,
      but have different characteristics.  */
   if ((s1->ts.type == BT_CLASS && s2->ts.type == BT_DERIVED)
       || (s1->ts.type == BT_DERIVED && s2->ts.type == BT_CLASS))
     return false;
 
-  return gfc_compare_types (&s1->ts, &s2->ts) || s2->ts.type == BT_ASSUMED;
+  return compare_type (s1, s2);
 }
 
 
@@ -1291,7 +1298,8 @@
   /* Check type and rank.  */
   if (type_must_agree)
     {
-      if (!compare_type (s1, s2) || !compare_type (s2, s1))
+      if (!compare_type_characteristics (s1, s2)
+	  || !compare_type_characteristics (s2, s1))
 	{
 	  snprintf (errmsg, err_len, "Type mismatch in argument '%s' (%s/%s)",
 		    s1->name, gfc_typename (&s1->ts), gfc_typename (&s2->ts));
@@ -1510,7 +1518,7 @@
     return true;
 
   /* Check type and rank.  */
-  if (!compare_type (r1, r2))
+  if (!compare_type_characteristics (r1, r2))
     {
       snprintf (errmsg, err_len, "Type mismatch in function result (%s/%s)",
 		gfc_typename (&r1->ts), gfc_typename (&r2->ts));
diff -Naur gcc-8.2.0/gcc/fortran/module.c gcc-8-20181012/gcc/fortran/module.c
--- gcc-8.2.0/gcc/fortran/module.c	2018-07-16 21:59:44.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/module.c	2018-07-26 19:28:18.000000000 +0300
@@ -4100,6 +4100,9 @@
     minit ("UNIFORM", 3),
     minit ("LINEAR", 4),
     minit ("ALIGNED", 5),
+    minit ("LINEAR_REF", 33),
+    minit ("LINEAR_VAL", 34),
+    minit ("LINEAR_UVAL", 35),
     minit (NULL, -1)
 };
 
@@ -4142,7 +4145,10 @@
 	    }
 	  for (n = ods->clauses->lists[OMP_LIST_LINEAR]; n; n = n->next)
 	    {
-	      mio_name (4, omp_declare_simd_clauses);
+	      if (n->u.linear_op == OMP_LINEAR_DEFAULT)
+		mio_name (4, omp_declare_simd_clauses);
+	      else
+		mio_name (32 + n->u.linear_op, omp_declare_simd_clauses);
 	      mio_symbol_ref (&n->sym);
 	      mio_expr (&n->expr);
 	    }
@@ -4183,11 +4189,20 @@
 	    case 4:
 	    case 5:
 	      *ptrs[t - 3] = n = gfc_get_omp_namelist ();
+	    finish_namelist:
+	      n->where = gfc_current_locus;
 	      ptrs[t - 3] = &n->next;
 	      mio_symbol_ref (&n->sym);
 	      if (t != 3)
 		mio_expr (&n->expr);
 	      break;
+	    case 33:
+	    case 34:
+	    case 35:
+	      *ptrs[1] = n = gfc_get_omp_namelist ();
+	      n->u.linear_op = (enum gfc_omp_linear_op) (t - 32);
+	      t = 4;
+	      goto finish_namelist;
 	    }
 	}
     }
diff -Naur gcc-8.2.0/gcc/fortran/resolve.c gcc-8-20181012/gcc/fortran/resolve.c
--- gcc-8.2.0/gcc/fortran/resolve.c	2018-06-25 10:49:27.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/resolve.c	2018-10-08 17:20:40.000000000 +0300
@@ -8658,6 +8658,14 @@
       if (!sym->ts.u.cl)
 	sym->ts.u.cl = target->ts.u.cl;
 
+      if (sym->ts.deferred && target->expr_type == EXPR_VARIABLE
+	  && target->symtree->n.sym->attr.dummy
+	  && sym->ts.u.cl == target->ts.u.cl)
+	{
+	  sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);
+	  sym->ts.deferred = 1;
+	}
+
       if (!sym->ts.u.cl->length
 	  && !sym->ts.deferred
 	  && target->expr_type == EXPR_CONSTANT)
@@ -8670,7 +8678,7 @@
 		|| sym->ts.u.cl->length->expr_type != EXPR_CONSTANT)
 		&& target->expr_type != EXPR_VARIABLE)
 	{
-	  sym->ts.u.cl = gfc_get_charlen();
+	  sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);
 	  sym->ts.deferred = 1;
 
 	  /* This is reset in trans-stmt.c after the assignment
@@ -12050,6 +12058,7 @@
      namespace.  14.6.1.3 of the standard and the discussion on
      comp.lang.fortran.  */
   if (sym->ns != sym->ts.u.derived->ns
+      && !sym->ts.u.derived->attr.use_assoc
       && sym->ns->proc_name->attr.if_source != IFSRC_IFBODY)
     {
       gfc_symbol *s;
@@ -12404,7 +12413,8 @@
     }
 
   /* An elemental function is required to return a scalar 12.7.1  */
-  if (sym->attr.elemental && sym->attr.function && sym->as)
+  if (sym->attr.elemental && sym->attr.function
+      && (sym->as || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)))
     {
       gfc_error ("ELEMENTAL function %qs at %L must have a scalar "
 		 "result", sym->name, &sym->declared_at);
diff -Naur gcc-8.2.0/gcc/fortran/simplify.c gcc-8-20181012/gcc/fortran/simplify.c
--- gcc-8.2.0/gcc/fortran/simplify.c	2018-06-07 21:17:49.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/simplify.c	2018-09-05 06:26:17.000000000 +0300
@@ -5509,54 +5509,57 @@
   gfc_expr *result;
   int kind;
 
-  if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)
+  /* First check p.  */
+  if (p->expr_type != EXPR_CONSTANT)
     return NULL;
 
-  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
-  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
-
-  switch (a->ts.type)
+  /* p shall not be 0.  */
+  switch (p->ts.type)
     {
       case BT_INTEGER:
 	if (mpz_cmp_ui (p->value.integer, 0) == 0)
 	  {
-	    /* Result is processor-dependent. This processor just opts
-	      to not handle it at all.  */
-	    gfc_error ("Second argument of MODULO at %L is zero", &a->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MODULO at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-	mpz_fdiv_r (result->value.integer, a->value.integer, p->value.integer);
-
 	break;
-
       case BT_REAL:
 	if (mpfr_cmp_ui (p->value.real, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument of MODULO at %L is zero", &p->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MODULO at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-
-	gfc_set_model_kind (kind);
-	mpfr_fmod (result->value.real, a->value.real, p->value.real,
-		   GFC_RND_MODE);
-	if (mpfr_cmp_ui (result->value.real, 0) != 0)
-	  {
-	    if (mpfr_signbit (a->value.real) != mpfr_signbit (p->value.real))
-	      mpfr_add (result->value.real, result->value.real, p->value.real,
-			GFC_RND_MODE);
-	  }
-	else
-	  mpfr_copysign (result->value.real, result->value.real,
-			 p->value.real, GFC_RND_MODE);
 	break;
-
       default:
 	gfc_internal_error ("gfc_simplify_modulo(): Bad arguments");
     }
 
+  if (a->expr_type != EXPR_CONSTANT)
+    return NULL;
+
+  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
+  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
+
+  if (a->ts.type == BT_INTEGER)
+	mpz_fdiv_r (result->value.integer, a->value.integer, p->value.integer);
+  else
+    {
+      gfc_set_model_kind (kind);
+      mpfr_fmod (result->value.real, a->value.real, p->value.real,
+                 GFC_RND_MODE);
+      if (mpfr_cmp_ui (result->value.real, 0) != 0)
+        {
+          if (mpfr_signbit (a->value.real) != mpfr_signbit (p->value.real))
+            mpfr_add (result->value.real, result->value.real, p->value.real,
+                      GFC_RND_MODE);
+	    }
+	  else
+        mpfr_copysign (result->value.real, result->value.real,
+                       p->value.real, GFC_RND_MODE);
+    }
+
   return range_check (result, "MODULO");
 }
 
diff -Naur gcc-8.2.0/gcc/fortran/trans.c gcc-8-20181012/gcc/fortran/trans.c
--- gcc-8.2.0/gcc/fortran/trans.c	2018-01-26 23:14:09.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/trans.c	2018-09-01 11:11:34.000000000 +0300
@@ -407,7 +407,12 @@
   if (vptr)
     span = gfc_vptr_size_get (vptr);
   else if (decl)
-    span = get_array_span (type, decl);
+    {
+      if (TREE_CODE (decl) == COMPONENT_REF)
+	span = gfc_conv_descriptor_span_get (decl);
+      else
+	span = get_array_span (type, decl);
+    }
 
   /* If a non-null span has been generated reference the element with
      pointer arithmetic.  */
diff -Naur gcc-8.2.0/gcc/fortran/trans-array.c gcc-8-20181012/gcc/fortran/trans-array.c
--- gcc-8.2.0/gcc/fortran/trans-array.c	2018-07-02 22:28:11.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/trans-array.c	2018-09-18 20:54:20.000000000 +0300
@@ -3414,11 +3414,7 @@
   if (is_pointer_array (info->descriptor))
     {
       if (TREE_CODE (info->descriptor) == COMPONENT_REF)
-	{
-	  decl = gfc_evaluate_now (info->descriptor, &se->pre);
-	  GFC_DECL_PTR_ARRAY_P (decl) = 1;
-	  TREE_USED (decl) = 1;
-	}
+	decl = info->descriptor;
       else if (TREE_CODE (info->descriptor) == INDIRECT_REF)
 	decl = TREE_OPERAND (info->descriptor, 0);
 
@@ -3659,11 +3655,7 @@
       && is_pointer_array (se->expr))
     {
       if (TREE_CODE (se->expr) == COMPONENT_REF)
-	{
-	  decl = gfc_evaluate_now (se->expr, &se->pre);
-	  GFC_DECL_PTR_ARRAY_P (decl) = 1;
-	  TREE_USED (decl) = 1;
-	}
+	decl = se->expr;
       else if (TREE_CODE (se->expr) == INDIRECT_REF)
 	decl = TREE_OPERAND (se->expr, 0);
       else
@@ -9505,6 +9497,9 @@
 
   sym = expr->symtree->n.sym;
 
+  if (sym->attr.associate_var)
+    return false;
+
   /* An allocatable class variable with no reference.  */
   if (sym->ts.type == BT_CLASS
       && CLASS_DATA (sym)->attr.allocatable
diff -Naur gcc-8.2.0/gcc/fortran/trans-decl.c gcc-8-20181012/gcc/fortran/trans-decl.c
--- gcc-8.2.0/gcc/fortran/trans-decl.c	2018-03-14 03:56:48.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/trans-decl.c	2018-09-18 20:54:20.000000000 +0300
@@ -1543,6 +1543,13 @@
       /* Dummy variables should already have been created.  */
       gcc_assert (sym->backend_decl);
 
+      /* However, the string length of deferred arrays must be set.  */
+      if (sym->ts.type == BT_CHARACTER
+	  && sym->ts.deferred
+	  && sym->attr.dimension
+	  && sym->attr.allocatable)
+	gfc_defer_symbol_init (sym);
+
       if (sym->attr.pointer && sym->attr.dimension && sym->ts.type != BT_CLASS)
 	GFC_DECL_PTR_ARRAY_P (sym->backend_decl) = 1;
 
diff -Naur gcc-8.2.0/gcc/fortran/trans-expr.c gcc-8-20181012/gcc/fortran/trans-expr.c
--- gcc-8.2.0/gcc/fortran/trans-expr.c	2018-06-25 10:49:27.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/trans-expr.c	2018-09-18 20:54:20.000000000 +0300
@@ -1505,7 +1505,6 @@
   gfc_start_block (&block);
 
   lhs = gfc_copy_expr (code->expr1);
-  gfc_add_data_component (lhs);
 
   rhs = gfc_copy_expr (code->expr1);
   gfc_add_vptr_component (rhs);
@@ -1523,11 +1522,15 @@
     {
       gfc_array_spec *tmparr = gfc_get_array_spec ();
       *tmparr = *CLASS_DATA (code->expr1)->as;
+      /* Adding the array ref to the class expression results in correct
+	 indexing to the dynamic type.  */
       gfc_add_full_array_ref (lhs, tmparr);
       tmp = gfc_trans_class_array_init_assign (rhs, lhs, code->expr1);
     }
   else
     {
+      /* Scalar initialization needs the _data component.  */
+      gfc_add_data_component (lhs);
       sz = gfc_copy_expr (code->expr1);
       gfc_add_vptr_component (sz);
       gfc_add_size_component (sz);
@@ -2234,7 +2237,8 @@
   if (!cl->length)
     {
       gfc_expr* expr_flat;
-      gcc_assert (expr);
+      if (!expr)
+	return;
       expr_flat = gfc_copy_expr (expr);
       flatten_array_ctors_without_strlen (expr_flat);
       gfc_resolve_expr (expr_flat);
diff -Naur gcc-8.2.0/gcc/fortran/trans-stmt.c gcc-8-20181012/gcc/fortran/trans-stmt.c
--- gcc-8.2.0/gcc/fortran/trans-stmt.c	2018-05-20 14:07:44.000000000 +0300
+++ gcc-8-20181012/gcc/fortran/trans-stmt.c	2018-10-08 16:02:36.000000000 +0300
@@ -1887,7 +1887,6 @@
 	}
 
       if (sym->ts.type == BT_CHARACTER
-	  && sym->ts.deferred
 	  && !sym->attr.select_type_temporary
 	  && VAR_P (sym->ts.u.cl->backend_decl)
 	  && se.string_length != sym->ts.u.cl->backend_decl)
diff -Naur gcc-8.2.0/gcc/gcov.c gcc-8-20181012/gcc/gcov.c
--- gcc-8.2.0/gcc/gcov.c	2018-02-27 17:11:08.000000000 +0300
+++ gcc-8-20181012/gcc/gcov.c	2018-09-18 12:32:09.000000000 +0300
@@ -536,6 +536,7 @@
 static void print_usage (int) ATTRIBUTE_NORETURN;
 static void print_version (void) ATTRIBUTE_NORETURN;
 static void process_file (const char *);
+static void process_all_functions (void);
 static void generate_results (const char *);
 static void create_file_names (const char *);
 static char *canonicalize_name (const char *);
@@ -791,6 +792,7 @@
 
       if (flag_intermediate_format || argno == argc - 1)
 	{
+	  process_all_functions ();
 	  generate_results (argv[argno]);
 	  release_structures ();
 	}
@@ -1066,7 +1068,8 @@
 	}
 
       /* Follow with lines associated with the source file.  */
-      output_intermediate_line (gcov_file, &src->lines[line_num], line_num);
+      if (line_num < src->lines.size ())
+	output_intermediate_line (gcov_file, &src->lines[line_num], line_num);
     }
 }
 
@@ -1132,11 +1135,14 @@
 {
   create_file_names (file_name);
   read_graph_file ();
-  if (functions.empty ())
-    return;
-
   read_count_file ();
+}
+
+/* Process all functions in all files.  */
 
+static void
+process_all_functions (void)
+{
   hash_map<function_start_pair_hash, function_info *> fn_map;
 
   /* Identify group functions.  */
@@ -1213,7 +1219,6 @@
 	  if (fn->is_group)
 	    fn->lines.resize (fn->end_line - fn->start_line + 1);
 
-
 	  solve_flow_graph (fn);
 	  if (fn->has_catch)
 	    find_exception_blocks (fn);
diff -Naur gcc-8.2.0/gcc/gengtype-lex.c gcc-8-20181012/gcc/gengtype-lex.c
--- gcc-8.2.0/gcc/gengtype-lex.c	2018-07-26 12:50:02.000000000 +0300
+++ gcc-8-20181012/gcc/gengtype-lex.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,2945 +0,0 @@
-#ifdef HOST_GENERATOR_FILE
-#include "config.h"
-#else
-#include "bconfig.h"
-#endif
-#line 2 "gengtype-lex.c"
-
-#line 4 "gengtype-lex.c"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 1
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern int yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-    #define YY_LESS_LINENO(n)
-    #define YY_LINENO_REWIND_TO(ptr)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        yy_size_t yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = NULL;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
-
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-
-#define yywrap() (/*CONSTCOND*/1)
-#define YY_SKIP_YYWRAP
-
-typedef unsigned char YY_CHAR;
-
-FILE *yyin = NULL, *yyout = NULL;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
-#ifdef yytext_ptr
-#undef yytext_ptr
-#endif
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yynoreturn yy_fatal_error (yyconst char* msg  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-
-#define YY_NUM_RULES 53
-#define YY_END_OF_BUFFER 54
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_accept[561] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,   54,   41,
-       38,   50,   41,   50,   39,   41,   41,   39,   39,   39,
-       39,   39,   35,    9,    9,   33,   35,   15,   35,   33,
-       33,   25,   35,   35,   35,   35,   35,   35,   35,   35,
-       14,   35,   35,   35,   35,   35,   35,   35,   35,   35,
-       35,   35,   35,   35,   13,    9,   35,   46,   44,   51,
-       51,    0,   42,    0,    0,    0,   43,   36,   43,    0,
-       39,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   39,   39,   39,   39,   39,    9,    0,   29,    0,
-        0,    0,    0,    7,    0,   25,   28,   28,    0,   28,
-
-        0,    0,    0,    0,    0,    0,    0,   30,   10,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    9,    0,    0,    0,    0,   47,   49,   48,   40,
-        0,   37,    0,    0,    0,    0,    0,    0,    0,   39,
-       39,   39,   39,   39,   39,   31,   32,    0,    8,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   34,    0,    0,
-
-        0,   39,    0,    0,    0,    0,    0,    0,    0,   39,
-       39,   39,   39,   39,   39,    0,    0,    0,    0,    0,
-       16,   16,   16,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,   26,   26,   26,    0,   26,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,   39,    0,    0,    0,
-        0,    0,    0,    0,   39,   39,   39,   39,   39,   39,
-        0,    0,    0,    0,    0,    0,    0,    0,   21,   21,
-       21,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       24,   24,   24,    0,    0,    0,    0,    0,    0,    0,
-        0,    4,    4,    4,   39,   39,   39,   39,    3,    3,
-        3,    0,    0,    0,    0,    0,   19,   19,   19,   11,
-       11,   11,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   17,   17,   17,
-        0,    0,    0,    0,    0,    0,    5,    5,    5,    6,
-        6,    6,    2,    2,    2,   39,    0,    0,    0,    0,
-        0,   12,   12,   12,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,   28,   18,   18,   18,    0,    0,
-        0,    0,    0,    0,    1,    1,    1,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   26,
-       26,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       12,   12,   20,   20,   20,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   22,   22,   22,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,   23,   23,   23,    0,   52,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,   28,   28,   28,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   27,    0,    0,    0,    0,
-        0,   45,    0,    0,    0,    0,    0,    0,    0,    0
-    } ;
-
-static yyconst YY_CHAR yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    4,    5,    6,    1,    4,    7,    8,    9,
-       10,   11,    4,    4,    4,   12,   13,   14,   14,   14,
-       14,   15,   14,   16,   14,   14,   14,   17,    4,    4,
-        4,    4,    4,    1,   18,   19,   20,   21,   22,   23,
-       24,   25,   26,   27,   27,   28,   29,   30,   31,   32,
-       27,   33,   34,   35,   36,   27,   37,   27,   38,   27,
-       39,   40,   41,   42,   43,    1,   44,   45,   46,   47,
-
-       48,   49,   50,   51,   52,   53,   53,   54,   55,   56,
-       57,   58,   53,   59,   60,   61,   62,   63,   53,   64,
-       65,   66,    4,    4,    4,   67,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst YY_CHAR yy_meta[68] =
-    {   0,
-        1,    2,    3,    1,    1,    1,    1,    1,    1,    4,
-        5,    1,    1,    6,    6,    7,    8,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
-        9,    9,    9,    9,    9,    9,    9,    9,   10,    1,
-        1,    1,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
-       11,   11,   11,   11,   11,   11,    1
-    } ;
-
-static yyconst flex_uint16_t yy_base[608] =
-    {   0,
-        0,   67,  134,   16,   16,   17,   18,   20, 1232, 2403,
-     2403,   19, 1191,   19,   31,   41,   43,   32,   33,   34,
-       35,   36, 2403,   23,   52, 2403,   51, 2403, 1190, 1217,
-       33,   46,  201,  268,   26,   33,   63,   81, 1187, 1224,
-     2403,   54,   65,   57,   62,   73,  188,  189,   83,  190,
-      191,  184,  186,  202, 2403,  118, 1224,    0, 2403, 1212,
-     1211,  219, 2403,    0, 1215, 1219, 2403, 2403, 1218,  108,
-      214, 1203,  254,  235, 1165, 1154, 1156, 1151, 1159,  236,
-     1166,  247,  284,  287,  230,  288,   63,  221, 2403, 1210,
-     1204, 1208, 1198, 2403, 1206,  213, 2403,  294, 1173, 1186,
-
-     1171,  234,  194,   92,  224,  253, 1160, 2403, 2403,  236,
-      275,  281,  261,  232,  266,  272,  282,  267,  287,  289,
-      296,  263,  299,  295,  301,  290,  302,  298,  307,  310,
-      311,  352, 1198, 1197,  368,    0, 2403, 2403, 2403, 2403,
-     1195, 2403, 1195, 1152, 1134,  306, 1136, 1141, 1143,  375,
-      358,  376,  374,  362,  381, 2403, 2403, 1188, 2403,  364,
-     1173, 1187,  341,  353,  351,  438,  364,  355,  343,  330,
-      421,  422,  356,  428,  357,  423,  365,  505,  426,  425,
-      429,  337,  430,  427,  431,  433,  434,  436,  432,  435,
-      437,  441,  438,  443,  442,  465, 1185, 2403,  570,    0,
-
-     1185,  392, 1126, 1137, 1123, 1120, 1133, 1123, 1113,  502,
-      518,  485,  521,  523,  524, 1162,  636,  496,  376,  499,
-     2403,  526, 1146,  505,  518, 1146,  472,  440,  498,  703,
-      500,  502,  503, 2403,  769,  548,  102, 1144,  520,  522,
-      532,  521,  540,  523,  524,  526,  547,  529,  548,  551,
-      192,  567,  555,  556,  831,    0,  586, 1100, 1100, 1106,
-     1111, 1109, 1099, 1098,  898,  595,  648,  591,  652,  965,
-     1032,  570,  573,  576,  371,  565, 1099, 1166, 2403,  653,
-     1136,  625,  561,    0,  656, 1121, 1119,  643, 1093, 1098,
-     1100, 1091, 1089,  548,  607,  636,  633,  626,  629,  635,
-
-      631,  637,  651,  640,  653,  657,  658,  686,  704, 1233,
-     2403,  719, 1128,    0,    0, 1088, 1097, 1081, 1089,    0,
-     1088, 2403,  720, 1118, 1300, 1367, 1434,  724, 2403,  721,
-     1117,  660,  662,  666,  702,  699, 2403,  729, 1116, 2403,
-      730, 1115, 1501, 1100, 1098, 1096, 1094, 1070, 1082, 1062,
-      691, 1068, 1066,  689, 1066, 1061,  696,  697,  718,  719,
-      698,  722,  734, 1568,  723,  727,  725, 2403,  760, 1103,
-        0,    0,    0,    0, 1070,  758, 2403,  761, 1101, 2403,
-      762, 1100, 2403,  764, 1098, 1635,  752,  749,  760,  766,
-      772, 2403,  783, 1097, 1085, 1078, 1076, 1061, 1041, 1035,
-
-     1050, 1049,  796, 1041, 1031, 1033, 1040, 1026, 1034,  738,
-      751,  787,  771,  776, 1068, 2403,  807, 1067,  774, 1702,
-      786,    0,    0,  825, 2403,  809, 1066,  822,  820,  827,
-      770,  824, 1039, 1056, 1037, 1036,  858, 1017, 1016, 2403,
-      850, 1061, 1014, 1022, 1026, 1052, 1017,  825,  828,  831,
-     2403, 1064, 2403,  861, 1048,    0, 1029,  799,  838,  850,
-      834,  846, 1044, 1044, 1028, 1023, 1016, 1011,  996, 1041,
-      826,  849, 1769,    0, 1017,  857,  859,  862,  865,  866,
-     1028, 1020, 1030, 1025,  989, 1005, 1836, 2403,  910, 1030,
-        0, 1037,  885,  864,  886,  887,  889,  996,  987, 1005,
-
-     1007,  965, 2403,  919, 1007,    0, 2403,  902,  903,  910,
-      893, 1000,  988,  978,  997,    0,  911,  948,  991,  989,
-      980,  965,    0,  904,  943,  946,  927,  976,  973,  972,
-      938,    0,  923,  978,  981,  941,  959,  983,  935,  929,
-      921,  923,    0,  986,  989, 2403,  999,  909,  861,  786,
-      771, 2403,  694,  589,  496, 1008,  360, 1010,   91, 2403,
-     1903, 1914, 1925, 1936, 1947, 1957, 1968, 1979, 1990, 2001,
-     2011, 2022, 2033, 2044, 2055, 2066, 2077, 2087, 2097, 2108,
-     2118, 2129, 2140, 2151, 2162, 2172, 2182, 2193, 2203, 2213,
-     2223, 2233, 2243, 2254, 2263, 2274, 2285, 2296, 2307, 2318,
-
-     2329, 2339, 2350, 2360, 2371, 2381, 2391
-    } ;
-
-static yyconst flex_int16_t yy_def[608] =
-    {   0,
-      561,  561,  560,    3,  562,  562,  562,  562,  560,  560,
-      560,  563,  564,  565,  566,  560,  560,  566,  566,  566,
-      566,  566,  560,  560,  560,  560,  567,  560,  568,  560,
-      560,  560,  569,  569,   34,   34,   34,   34,  570,  560,
-      560,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,  560,  560,  571,  572,  560,  573,
-      573,  563,  560,  563,  560,  564,  560,  560,  574,  560,
-      566,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  566,  566,  566,  566,  566,  560,  567,  560,  567,
-      560,  568,  560,  560,  575,  560,  560,  560,   34,  560,
-
-       34,   34,   34,   34,   34,   34,  570,  560,  560,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,  560,  571,  571,  576,  577,  560,  560,  560,  560,
-      574,  560,  578,  560,  560,  560,  560,  560,  560,  566,
-      566,  566,  566,  566,  566,  560,  560,  575,  560,  560,
-      560,  579,   34,   34,   34,  569,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,  569,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,   34,   34,  576,  560,  576,  580,
-
-      578,  581,  560,  560,  560,  560,  560,  560,  560,  566,
-      566,  566,  566,  566,  566,  579,  582,   34,   34,   34,
-      560,  560,  560,   34,   34,  178,   34,   34,   34,  569,
-       34,   34,   34,  560,  560,  235,   34,  560,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   34,   34,   34,  569,  583,  581,  560,  560,  560,
-      560,  560,  560,  560,  566,  566,  566,  566,  566,  566,
-      582,   34,   34,   34,   34,   34,  569,  569,  560,  560,
-      560,   34,   34,  235,  235,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,   34,   34,   34,   34,   34,
-
-       34,   34,   34,   34,   34,   34,   34,   34,   34,  569,
-      560,  560,  560,  584,  585,  560,  560,  560,  560,  586,
-      560,  560,  560,  560,  566,  566,  566,  566,  560,  560,
-      560,   34,   34,   34,   34,   34,  560,  560,  560,  560,
-      560,  560,  569,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,   34,   34,   34,   34,
-       34,   34,   34,  569,   34,   34,   34,  560,  560,  560,
-      587,  588,  589,  590,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  566,   34,   34,   34,   34,
-       34,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  560,  591,  560,  560,  560,  560,  560,  560,   34,
-       34,   34,   34,   34,  592,  560,  560,  560,   34,  569,
-       34,  593,  594,  560,  560,  560,  560,   34,   34,   34,
-       34,   34,  560,  560,  560,  560,  591,  560,  560,  560,
-      235,  560,  560,  560,  560,  560,  560,   34,   34,   34,
-      560,  595,  560,  560,  560,  596,  560,   34,   34,   34,
-       34,   34,  560,  560,  560,  560,  560,  560,  560,  560,
-       34,   34,  569,  597,  560,   34,   34,   34,   34,   34,
-      560,  560,  560,  560,  560,  560,  569,  560,  560,  560,
-      598,  560,   34,   34,   34,   34,   34,  560,  560,  560,
-
-      560,  560,  560,  560,  560,  599,  560,   34,   34,   34,
-       34,  560,  560,  560,  560,  600,   34,   34,  560,  560,
-      560,  560,  601,   34,  560,  560,  602,  560,  560,  560,
-      560,  603,   34,  560,  560,  602,  602,  604,  560,  560,
-      560,  560,  605,  560,  560,  560,  604,  560,  560,  560,
-      560,  560,  606,  560,  606,  607,  560,  607,  560,    0,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  560,  560,  560,  560,  560,  560
-    } ;
-
-static yyconst flex_uint16_t yy_nxt[2471] =
-    {   0,
-       10,   10,   11,   10,   12,   10,   10,   13,   10,   10,
-       10,   10,   14,   10,   10,   10,   10,   56,   59,   59,
-       59,   57,   59,   63,   87,   87,   60,   60,   61,   68,
-       61,   69,   70,   70,   70,   70,   70,   70,   10,   10,
-       10,   10,   73,   94,   80,   95,   74,   72,   72,   72,
-       72,   72,   72,   87,   87,   89,   99,  102,   64,   96,
-       96,   96,  103,   99,   87,   87,   10,   10,   16,   11,
-       10,   12,   17,   10,   13,   10,   10,   10,   10,   14,
-       10,   10,   10,   10,   99,   82,   75,   99,   76,   81,
-       90,   86,   99,   99,   84,   99,   83,  104,  105,   85,
-
-       77,   78,   79,   99,  114,   10,   10,   10,   10,   70,
-      110,  106,   18,   99,   19,  111,  296,  115,  112,  132,
-       87,  113,   99,  133,   72,  437,   20,   21,   22,  166,
-      119,  116,   99,   10,   23,   24,   25,   26,   27,   23,
-       28,   29,   26,   26,   26,   30,   31,   32,   32,   32,
-       26,   33,   34,   35,   33,   36,   33,   37,   38,   33,
-       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   39,   40,   23,   41,   33,   33,   42,   43,
-       44,   45,   46,   33,   33,   47,   33,   48,   33,   49,
-       50,   51,   33,   52,   53,   54,   33,   33,   33,   33,
-
-       55,   97,   98,   97,   97,   97,   97,   97,   97,   97,
-       97,   97,   97,   97,   99,   70,   99,  100,   99,   99,
-       99,   99,   99,   63,   99,   89,   96,   96,   96,  165,
-       72,   70,   99,  127,  124,  125,   80,   80,  308,   97,
-       97,   97,   97,  117,  126,  118,   72,  120,   70,  121,
-      128,  122,  123,  129,   99,   73,  167,  130,   64,   74,
-       90,  131,   99,   72,   99,  164,   99,   97,   97,   98,
-       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
-       97,   81,   81,   99,  100,   70,  168,  154,   70,   70,
-      150,   99,  169,   99,  173,  160,   99,   99,  101,   75,
-
-       72,   76,   99,   72,   72,   99,   97,   97,   97,   97,
-      161,   99,   99,   77,   78,   79,  172,   99,  170,   99,
-       99,  184,  179,  175,  171,   99,   99,  174,   99,   99,
-      152,   99,   99,  189,   97,  176,  181,   99,  177,  155,
-       99,   99,  178,  185,  151,  153,  180,  182,  190,  205,
-      187,  186,  183,  132,   87,  192,  191,  133,  196,   70,
-       99,  194,  193,   70,  206,  160,  188,   99,  218,  195,
-      198,   99,  219,   99,   72,   70,   70,   70,   72,  220,
-      161,   99,   70,   99,  224,   99,   99,   99,  226,  225,
-       72,   72,   72,   70,   99,   99,  226,   72,  229,  241,
-
-      273,   99,  559,  335,  231,  211,   99,  233,   72,  214,
-      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
-      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
-      199,  199,  199,  199,  210,  213,  212,  215,  221,  222,
-      221,  221,  221,  221,  221,  221,  221,  221,  221,  221,
-      221,   99,   99,   99,  223,   99,   99,   99,   99,   99,
-       99,   99,   99,   99,   99,   99,   99,   99,   99,  243,
-       99,   99,   99,   99,  232,  226,  221,  221,  221,  221,
-      227,  228,  230,  247,  244,  239,   70,  240,  251,  246,
-      242,  245,  248,  254,  250,   99,  249,  555,  252,  253,
-
-      278,   72,   99,   70,  221,  234,  235,  236,  234,  234,
-      234,  234,  234,  234,  234,  234,  234,  234,   72,   70,
-      237,  238,   70,  255,   70,   70,   99,  160,   99,   99,
-       99,  277,   99,   99,   72,   99,  267,   72,  272,   72,
-       72,  274,  161,  234,  234,  234,  234,  275,   99,  285,
-       99,   99,   99,   99,   99,  282,   99,  283,  226,   99,
-      276,  265,   99,  226,  560,  298,  268,  297,  300,  269,
-       99,  234,  198,  303,  302,  299,  266,   99,   99,  270,
-      305,   99,  309,  301,  226,   99,   99,   70,  332,  304,
-      333,   99,   70,  306,  334,   99,   70,   99,  353,  354,
-
-       99,  336,   72,   99,  307,  187,   99,   72,  343,  557,
-      310,   72,  199,  199,  199,  199,  199,  199,  199,  199,
-      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
-      199,  199,  199,  199,  199,  199,   97,   98,   97,   97,
-       97,   97,   97,   97,   97,   97,   97,   97,   97,   70,
-      325,  327,  100,   70,  160,   99,   99,  285,  355,   99,
-      346,   99,  356,   99,   72,   99,   99,   99,   72,  161,
-       99,  343,  560,  347,   97,   97,   97,   97,  357,  358,
-      361,   99,  363,   99,  362,  387,  359,   99,   99,  360,
-       99,  389,   99,  326,  388,  555,   99,  226,  343,  328,
-
-      226,  365,   97,  279,  280,  279,  279,  279,  279,  279,
-      279,  279,  279,  279,  279,  279,   99,  364,  367,  281,
-      160,   70,   70,  390,  391,   70,   99,   99,   99,   99,
-      160,  160,   99,  366,   99,  161,   72,   72,  406,  410,
-       72,  279,  279,  279,  279,  161,  161,  402,   99,   99,
-      415,  403,   99,   99,  407,   99,  226,   99,  413,  424,
-      424,  160,   70,   70,   99,   70,  412,  421,   99,  279,
-      284,  285,  386,  414,  411,  420,  161,   72,   72,   99,
-       72,   99,   99,  419,  160,  161,  428,  286,  287,  431,
-       99,  429,  432,  288,  430,  448,   99,  441,  441,  161,
-
-       99,   99,   99,  415,   99,  437,   99,  554,  160,  343,
-       70,  442,  461,  289,  290,  291,   99,   99,  449,  450,
-      292,  343,  293,  161,  476,   72,  424,  424,  294,   99,
-      295,  311,  312,  311,  311,  311,  311,  311,  311,  311,
-      311,  311,  311,  311,  458,  462,  226,  313,  457,  460,
-       99,  285,   99,  459,   99,   99,   99,   99,   99,  441,
-      441,   99,  160,  477,   99,  415,  560,  479,   99,  311,
-      311,  311,  311,  560,  472,  478,   99,  161,  493,   99,
-       99,  437,  494,  495,  487,  471,  496,   99,  480,   99,
-      473,  497,   99,  509,   99,   99,   99,  311,  322,  323,
-
-      322,  322,  322,  322,  322,  322,  322,  322,  322,  322,
-      322,  160,  508,  510,  324,   99,   99,   99,  511,   99,
-      160,  226,  226,   99,  517,  553,  161,  226,  537,  537,
-      518,  524,   99,   99,   99,  161,  322,  322,  322,  322,
-       99,   99,  537,  537,  534,  535,  533,  535,  535,  525,
-      526,  536,  551,   99,  536,  437,  527,  226,  550,  161,
-      537,  537,  549,  542,  322,  329,  330,  329,  329,  329,
-      329,  329,  329,  329,  329,  329,  329,  329,   99,  534,
-      535,  331,  535,  535,  544,  545,  536,  544,  545,  536,
-      545,  545,  546,  541,  161,  546,  540,  539,  546,  548,
-
-      544,  545,  548,  329,  329,  329,  329,  531,  546,  544,
-      545,  544,  545,  530,  529,  548,  528,  546,  522,  546,
-      521,  520,  519,  162,  548,  437,  548,  515,  514,  513,
-      512,  329,   97,   98,   97,   97,   97,   97,   97,   97,
-       97,   97,   97,   97,   97,  507,  162,  502,  100,  437,
-      501,  500,  499,  498,  492,  486,  437,  437,  485,  484,
-      483,  482,  481,  475,  162,  216,  406,  470,  469,  468,
-       97,   97,   97,   97,  437,  467,  437,  437,  466,  465,
-      464,  463,  143,  162,  452,  447,  446,  445,  444,  443,
-      437,  439,  438,  437,  437,  436,  435,  434,   97,  337,
-
-      338,  337,  337,  337,  337,  337,  337,  337,  337,  337,
-      337,  337,  433,  162,  143,  339,  143,  143,  423,  162,
-      409,  408,  405,  404,  401,  400,  399,  398,  397,  396,
-      395,  162,  162,  143,  143,  376,  375,  337,  337,  337,
-      337,  374,  373,  372,  162,  352,  351,  350,  349,  348,
-      345,  344,  162,  321,  320,  319,  318,  317,  316,  315,
-      162,   99,  162,  216,  264,  337,  340,  341,  340,  340,
-      340,  340,  340,  340,  340,  340,  340,  340,  340,  263,
-      262,  261,  342,  260,  259,  258,  201,  198,  216,  162,
-      159,  209,  208,  207,  204,  203,  201,  142,  134,  134,
-
-      108,  163,  162,   99,  340,  340,  340,  340,  159,  157,
-      560,  156,  560,  149,  148,  147,  146,  145,  144,  143,
-      142,  560,  140,  139,  138,  134,  109,  108,   93,   92,
-       66,  560,  340,  368,  369,  368,  368,  368,  368,  368,
-      368,  368,  368,  368,  368,  368,  560,  560,  560,  370,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  368,  368,  368,  368,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  368,
-
-      377,  378,  377,  377,  377,  377,  377,  377,  377,  377,
-      377,  377,  377,  560,  560,  560,  379,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  377,  377,
-      377,  377,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  377,  380,  381,  380,
-      380,  380,  380,  380,  380,  380,  380,  380,  380,  380,
-      560,  560,  560,  382,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  560,  560,  560,  560,  380,  380,  380,  380,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  380,  383,  384,  383,  383,  383,  383,
-      383,  383,  383,  383,  383,  383,  383,  560,  560,  560,
-      385,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  383,  383,  383,  383,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      383,  392,  393,  392,  392,  392,  392,  392,  392,  392,
-      392,  392,  392,  392,  560,  560,  560,  394,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  392,
-      392,  392,  392,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  392,  416,  417,
-      416,  416,  416,  416,  416,  416,  416,  416,  416,  416,
-      416,  560,  560,  560,  418,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  560,  560,  560,  560,  560,  416,  416,  416,  416,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  416,  425,  426,  425,  425,  425,
-      425,  425,  425,  425,  425,  425,  425,  425,  560,  560,
-      560,  427,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  425,  425,  425,  425,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  425,  453,  454,  453,  453,  453,  453,  453,  453,
-      453,  453,  453,  453,  453,  560,  560,  560,  455,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      453,  453,  453,  453,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  453,  488,
-      489,  488,  488,  488,  488,  488,  488,  488,  488,  488,
-      488,  488,  560,  560,  560,  490,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  560,  560,  560,  560,  560,  560,  488,  488,  488,
-      488,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  488,  503,  504,  503,  503,
-      503,  503,  503,  503,  503,  503,  503,  503,  503,  560,
-      560,  560,  505,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  503,  503,  503,  503,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-
-      560,  560,  503,   15,   15,   15,   15,   15,   15,   15,
-       15,   15,   15,   15,   58,   58,   58,   58,   58,   58,
-       58,   58,   58,   58,   58,   62,   62,   62,   62,   62,
-       62,   62,   62,   62,   62,   62,   65,   65,   65,   65,
-       65,   65,   65,   65,   65,   65,   65,   67,   67,   67,
-       67,   67,   67,   67,   67,   67,   67,   67,   71,  560,
-      560,  560,   71,   71,   71,   71,  560,   71,   88,   88,
-       88,   88,   88,   88,   88,   88,   88,   88,   88,   91,
-       91,   91,   91,   91,   91,   91,   91,   91,   91,   91,
-       99,   99,   99,   99,   99,   99,   99,   99,   99,   99,
-
-       99,  107,  107,  107,  107,  107,  107,  107,  107,  107,
-      560,  107,  135,  560,  560,  560,  560,  560,  560,  560,
-      560,  135,  136,  136,  560,  136,  560,  136,  136,  136,
-      136,  136,  136,  137,  137,  137,  137,  137,  137,  137,
-      137,  137,  137,  137,  141,  141,  141,  141,  141,  141,
-      141,  141,  141,  141,  141,  158,  158,  158,  158,  158,
-      158,  158,  158,  158,  158,  158,  197,  197,  197,  197,
-      197,  197,  197,  197,  197,  197,  197,  200,  200,  560,
-      200,  560,  200,  200,  200,  200,  200,  200,  202,  560,
-      560,  560,  560,  560,  560,  202,  560,  202,  217,  560,
-
-      560,  560,  560,  560,  560,  217,  560,  217,  256,  256,
-      560,  256,  560,  256,  256,  256,  256,  256,  256,  257,
-      560,  560,  560,  257,  257,  257,  257,  560,  257,  271,
-      271,  271,  271,  271,  271,  271,  271,  271,  271,  271,
-      314,  314,  560,  314,  560,  314,  314,  314,  314,  314,
-      314,  371,  371,  560,  371,  560,  371,  371,  371,  371,
-      371,  371,  322,  322,  322,  322,  322,  560,  560,  322,
-      560,  322,  329,  329,  329,  329,  329,  560,  560,  329,
-      560,  329,  422,  422,  560,  422,  560,  422,  422,  422,
-      422,  422,  422,  377,  377,  377,  377,  377,  560,  560,
-
-      377,  560,  377,  380,  380,  380,  380,  380,  560,  560,
-      380,  560,  380,  383,  383,  383,  383,  383,  560,  560,
-      383,  560,  383,  440,  440,  440,  440,  440,  560,  440,
-      440,  560,  440,  451,  451,  451,  451,  451,  560,  560,
-      451,  560,  451,  456,  456,  560,  456,  560,  456,  456,
-      456,  456,  456,  456,  425,  425,  425,  425,  425,  560,
-      560,  425,  560,  425,  217,  560,  560,  560,  560,  560,
-      560,  217,  560,  217,  474,  474,  560,  474,  560,  474,
-      474,  474,  474,  474,  474,  491,  491,  560,  491,  560,
-      491,  491,  491,  491,  491,  491,  506,  506,  560,  506,
-
-      560,  506,  506,  506,  506,  506,  506,  516,  516,  560,
-      516,  560,  516,  516,  516,  516,  516,  516,  523,  523,
-      560,  523,  560,  523,  523,  523,  523,  523,  523,  532,
-      532,  560,  532,  560,  532,  532,  532,  532,  532,  532,
-      538,  538,  560,  560,  560,  560,  560,  538,  560,  538,
-      543,  543,  560,  543,  560,  543,  543,  543,  543,  543,
-      543,  547,  547,  547,  560,  547,  547,  547,  547,  560,
-      547,  552,  552,  560,  552,  560,  552,  552,  552,  552,
-      552,  552,  556,  560,  560,  560,  560,  560,  560,  556,
-      560,  556,  558,  558,  558,  560,  558,  558,  558,  558,
-
-      560,  558,    9,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560
-    } ;
-
-static yyconst flex_int16_t yy_chk[2471] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    4,    5,    6,
-        7,    4,    8,   12,   24,   24,    5,    6,    7,   14,
-        8,   14,   15,   18,   19,   20,   21,   22,    1,    1,
-        1,    1,   16,   31,   17,   31,   16,   15,   18,   19,
-       20,   21,   22,   25,   25,   27,   35,   35,   12,   32,
-       32,   32,   36,   36,   87,   87,    1,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,   42,   18,   16,   44,   16,   17,
-       27,   22,   45,   37,   20,   43,   19,   37,   38,   21,
-
-       16,   16,   16,   46,   44,    2,    2,    2,    2,   70,
-       42,   38,    2,   49,    2,   43,  237,   45,   43,   56,
-       56,   43,  104,   56,   70,  559,    2,    2,    2,  104,
-       49,   46,  237,    2,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-
-        3,   33,   33,   33,   33,   33,   33,   33,   33,   33,
-       33,   33,   33,   33,   52,   71,   53,   33,   47,   48,
-       50,   51,  251,   62,  103,   88,   96,   96,   96,  103,
-       71,   85,   54,   53,   52,   52,   74,   80,  251,   33,
-       33,   33,   33,   47,   52,   48,   85,   50,   82,   51,
-       53,   51,   51,   54,  105,   73,  105,   54,   62,   73,
-       88,   54,  114,   82,  102,  102,  110,   33,   34,   34,
-       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
-       34,   74,   80,  106,   34,   83,  106,   85,   84,   86,
-       82,  113,  110,  122,  114,   98,  115,  118,   34,   73,
-
-       83,   73,  116,   84,   86,  111,   34,   34,   34,   34,
-       98,  112,  117,   73,   73,   73,  113,  119,  111,  120,
-      126,  122,  118,  116,  112,  124,  121,  115,  128,  123,
-       84,  125,  127,  126,   34,  117,  120,  129,  117,   86,
-      130,  131,  117,  123,   83,   84,  119,  121,  126,  146,
-      125,  124,  121,  132,  132,  128,  127,  132,  131,  151,
-      170,  130,  129,  154,  146,  160,  125,  182,  163,  130,
-      135,  163,  164,  169,  151,  153,  150,  152,  154,  165,
-      160,  165,  155,  164,  167,  168,  173,  175,  170,  168,
-      153,  150,  152,  202,  167,  177,  169,  155,  173,  182,
-
-      219,  275,  557,  275,  175,  151,  219,  177,  202,  154,
-      135,  135,  135,  135,  135,  135,  135,  135,  135,  135,
-      135,  135,  135,  135,  135,  135,  135,  135,  135,  135,
-      135,  135,  135,  135,  150,  153,  152,  155,  166,  166,
-      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,
-      166,  171,  172,  176,  166,  180,  179,  184,  174,  181,
-      183,  185,  189,  186,  187,  190,  188,  191,  193,  184,
-      228,  192,  195,  194,  176,  179,  166,  166,  166,  166,
-      171,  172,  174,  188,  185,  180,  212,  181,  192,  187,
-      183,  186,  189,  195,  191,  196,  190,  555,  193,  194,
-
-      228,  212,  227,  210,  166,  178,  178,  178,  178,  178,
-      178,  178,  178,  178,  178,  178,  178,  178,  210,  211,
-      178,  178,  213,  196,  214,  215,  218,  222,  229,  220,
-      231,  227,  232,  233,  211,  224,  212,  213,  218,  214,
-      215,  220,  222,  178,  178,  178,  178,  224,  225,  236,
-      239,  242,  240,  244,  245,  231,  246,  232,  229,  248,
-      225,  210,  241,  233,  236,  240,  213,  239,  242,  214,
-      243,  178,  199,  246,  244,  241,  211,  247,  249,  215,
-      248,  250,  252,  243,  245,  253,  254,  257,  272,  247,
-      273,  283,  268,  249,  274,  276,  266,  252,  294,  294,
-
-      272,  276,  257,  273,  250,  254,  274,  268,  283,  554,
-      253,  266,  199,  199,  199,  199,  199,  199,  199,  199,
-      199,  199,  199,  199,  199,  199,  199,  199,  199,  199,
-      199,  199,  199,  199,  199,  199,  217,  217,  217,  217,
-      217,  217,  217,  217,  217,  217,  217,  217,  217,  267,
-      266,  268,  217,  269,  280,  282,  298,  285,  295,  299,
-      288,  301,  295,  297,  267,  300,  296,  302,  269,  280,
-      304,  282,  285,  288,  217,  217,  217,  217,  296,  297,
-      300,  303,  302,  305,  301,  332,  298,  306,  307,  299,
-      332,  334,  333,  267,  333,  553,  334,  303,  305,  269,
-
-      304,  307,  217,  230,  230,  230,  230,  230,  230,  230,
-      230,  230,  230,  230,  230,  230,  308,  306,  309,  230,
-      312,  323,  330,  335,  336,  328,  357,  358,  361,  336,
-      338,  341,  335,  308,  309,  312,  323,  330,  354,  358,
-      328,  230,  230,  230,  230,  338,  341,  351,  359,  360,
-      363,  351,  362,  365,  354,  367,  357,  366,  361,  376,
-      376,  369,  378,  381,  363,  384,  360,  367,  410,  230,
-      235,  235,  328,  362,  359,  366,  369,  378,  381,  388,
-      384,  411,  387,  365,  393,  235,  387,  235,  235,  390,
-      389,  388,  391,  235,  389,  410,  390,  403,  403,  393,
-
-      431,  413,  391,  412,  419,  551,  414,  550,  417,  411,
-      426,  403,  431,  235,  235,  235,  421,  412,  413,  414,
-      235,  419,  235,  417,  458,  426,  424,  424,  235,  458,
-      235,  255,  255,  255,  255,  255,  255,  255,  255,  255,
-      255,  255,  255,  255,  428,  432,  421,  255,  424,  430,
-      429,  441,  428,  429,  432,  448,  471,  430,  449,  437,
-      437,  450,  454,  459,  461,  472,  441,  461,  459,  255,
-      255,  255,  255,  437,  449,  460,  462,  454,  476,  472,
-      460,  549,  477,  478,  471,  448,  479,  476,  462,  477,
-      450,  480,  478,  494,  494,  479,  480,  255,  265,  265,
-
-      265,  265,  265,  265,  265,  265,  265,  265,  265,  265,
-      265,  489,  493,  495,  265,  493,  495,  496,  497,  497,
-      504,  496,  508,  511,  509,  548,  489,  511,  527,  527,
-      510,  517,  508,  509,  524,  504,  265,  265,  265,  265,
-      510,  517,  536,  536,  525,  525,  524,  526,  526,  518,
-      518,  525,  542,  533,  526,  541,  518,  533,  540,  525,
-      537,  537,  539,  531,  265,  270,  270,  270,  270,  270,
-      270,  270,  270,  270,  270,  270,  270,  270,  518,  534,
-      534,  270,  535,  535,  538,  538,  534,  544,  544,  535,
-      545,  545,  538,  530,  534,  544,  529,  528,  545,  538,
-
-      547,  547,  544,  270,  270,  270,  270,  522,  547,  556,
-      556,  558,  558,  521,  520,  547,  519,  556,  515,  558,
-      514,  513,  512,  505,  556,  502,  558,  501,  500,  499,
-      498,  270,  271,  271,  271,  271,  271,  271,  271,  271,
-      271,  271,  271,  271,  271,  492,  490,  486,  271,  485,
-      484,  483,  482,  481,  475,  470,  469,  468,  467,  466,
-      465,  464,  463,  457,  455,  452,  447,  446,  445,  444,
-      271,  271,  271,  271,  443,  442,  439,  438,  436,  435,
-      434,  433,  427,  418,  415,  409,  408,  407,  406,  405,
-      404,  402,  401,  400,  399,  398,  397,  396,  271,  277,
-
-      277,  277,  277,  277,  277,  277,  277,  277,  277,  277,
-      277,  277,  395,  394,  385,  277,  382,  379,  375,  370,
-      356,  355,  353,  352,  350,  349,  348,  347,  346,  345,
-      344,  342,  339,  331,  324,  321,  319,  277,  277,  277,
-      277,  318,  317,  316,  313,  293,  292,  291,  290,  289,
-      287,  286,  281,  264,  263,  262,  261,  260,  259,  258,
-      238,  226,  223,  216,  209,  277,  278,  278,  278,  278,
-      278,  278,  278,  278,  278,  278,  278,  278,  278,  208,
-      207,  206,  278,  205,  204,  203,  201,  197,  162,  161,
-      158,  149,  148,  147,  145,  144,  143,  141,  134,  133,
-
-      107,  101,  100,   99,  278,  278,  278,  278,   95,   93,
-       92,   91,   90,   81,   79,   78,   77,   76,   75,   72,
-       69,   66,   65,   61,   60,   57,   40,   39,   30,   29,
-       13,    9,  278,  310,  310,  310,  310,  310,  310,  310,
-      310,  310,  310,  310,  310,  310,    0,    0,    0,  310,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,  310,  310,  310,  310,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,  310,
-
-      325,  325,  325,  325,  325,  325,  325,  325,  325,  325,
-      325,  325,  325,    0,    0,    0,  325,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  325,  325,
-      325,  325,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,  325,  326,  326,  326,
-      326,  326,  326,  326,  326,  326,  326,  326,  326,  326,
-        0,    0,    0,  326,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,  326,  326,  326,  326,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,  326,  327,  327,  327,  327,  327,  327,
-      327,  327,  327,  327,  327,  327,  327,    0,    0,    0,
-      327,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,  327,  327,  327,  327,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-      327,  343,  343,  343,  343,  343,  343,  343,  343,  343,
-      343,  343,  343,  343,    0,    0,    0,  343,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,  343,
-      343,  343,  343,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,  343,  364,  364,
-      364,  364,  364,  364,  364,  364,  364,  364,  364,  364,
-      364,    0,    0,    0,  364,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,  364,  364,  364,  364,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,  364,  386,  386,  386,  386,  386,
-      386,  386,  386,  386,  386,  386,  386,  386,    0,    0,
-        0,  386,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,  386,  386,  386,  386,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,  386,  420,  420,  420,  420,  420,  420,  420,  420,
-      420,  420,  420,  420,  420,    0,    0,    0,  420,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-      420,  420,  420,  420,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  420,  473,
-      473,  473,  473,  473,  473,  473,  473,  473,  473,  473,
-      473,  473,    0,    0,    0,  473,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,    0,    0,    0,    0,  473,  473,  473,
-      473,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,  473,  487,  487,  487,  487,
-      487,  487,  487,  487,  487,  487,  487,  487,  487,    0,
-        0,    0,  487,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,  487,  487,  487,  487,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,  487,  561,  561,  561,  561,  561,  561,  561,
-      561,  561,  561,  561,  562,  562,  562,  562,  562,  562,
-      562,  562,  562,  562,  562,  563,  563,  563,  563,  563,
-      563,  563,  563,  563,  563,  563,  564,  564,  564,  564,
-      564,  564,  564,  564,  564,  564,  564,  565,  565,  565,
-      565,  565,  565,  565,  565,  565,  565,  565,  566,    0,
-        0,    0,  566,  566,  566,  566,    0,  566,  567,  567,
-      567,  567,  567,  567,  567,  567,  567,  567,  567,  568,
-      568,  568,  568,  568,  568,  568,  568,  568,  568,  568,
-      569,  569,  569,  569,  569,  569,  569,  569,  569,  569,
-
-      569,  570,  570,  570,  570,  570,  570,  570,  570,  570,
-        0,  570,  571,    0,    0,    0,    0,    0,    0,    0,
-        0,  571,  572,  572,    0,  572,    0,  572,  572,  572,
-      572,  572,  572,  573,  573,  573,  573,  573,  573,  573,
-      573,  573,  573,  573,  574,  574,  574,  574,  574,  574,
-      574,  574,  574,  574,  574,  575,  575,  575,  575,  575,
-      575,  575,  575,  575,  575,  575,  576,  576,  576,  576,
-      576,  576,  576,  576,  576,  576,  576,  577,  577,    0,
-      577,    0,  577,  577,  577,  577,  577,  577,  578,    0,
-        0,    0,    0,    0,    0,  578,    0,  578,  579,    0,
-
-        0,    0,    0,    0,    0,  579,    0,  579,  580,  580,
-        0,  580,    0,  580,  580,  580,  580,  580,  580,  581,
-        0,    0,    0,  581,  581,  581,  581,    0,  581,  582,
-      582,  582,  582,  582,  582,  582,  582,  582,  582,  582,
-      583,  583,    0,  583,    0,  583,  583,  583,  583,  583,
-      583,  584,  584,    0,  584,    0,  584,  584,  584,  584,
-      584,  584,  585,  585,  585,  585,  585,    0,    0,  585,
-        0,  585,  586,  586,  586,  586,  586,    0,    0,  586,
-        0,  586,  587,  587,    0,  587,    0,  587,  587,  587,
-      587,  587,  587,  588,  588,  588,  588,  588,    0,    0,
-
-      588,    0,  588,  589,  589,  589,  589,  589,    0,    0,
-      589,    0,  589,  590,  590,  590,  590,  590,    0,    0,
-      590,    0,  590,  591,  591,  591,  591,  591,    0,  591,
-      591,    0,  591,  592,  592,  592,  592,  592,    0,    0,
-      592,    0,  592,  593,  593,    0,  593,    0,  593,  593,
-      593,  593,  593,  593,  594,  594,  594,  594,  594,    0,
-        0,  594,    0,  594,  595,    0,    0,    0,    0,    0,
-        0,  595,    0,  595,  596,  596,    0,  596,    0,  596,
-      596,  596,  596,  596,  596,  597,  597,    0,  597,    0,
-      597,  597,  597,  597,  597,  597,  598,  598,    0,  598,
-
-        0,  598,  598,  598,  598,  598,  598,  599,  599,    0,
-      599,    0,  599,  599,  599,  599,  599,  599,  600,  600,
-        0,  600,    0,  600,  600,  600,  600,  600,  600,  601,
-      601,    0,  601,    0,  601,  601,  601,  601,  601,  601,
-      602,  602,    0,    0,    0,    0,    0,  602,    0,  602,
-      603,  603,    0,  603,    0,  603,  603,  603,  603,  603,
-      603,  604,  604,  604,    0,  604,  604,  604,  604,    0,
-      604,  605,  605,    0,  605,    0,  605,  605,  605,  605,
-      605,  605,  606,    0,    0,    0,    0,    0,    0,  606,
-        0,  606,  607,  607,  607,    0,  607,  607,  607,  607,
-
-        0,  607,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560,
-      560,  560,  560,  560,  560,  560,  560,  560,  560,  560
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* -*- indented-text -*- */
-/* Process source files and output type information.
-   Copyright (C) 2002-2018 Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify it under
-the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
-version.
-
-GCC is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-#define YY_NO_INPUT 1
-#line 24 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-#ifdef HOST_GENERATOR_FILE
-#include "config.h"
-#define GENERATOR_FILE 1
-#else
-#include "bconfig.h"
-#endif
-#include "system.h"
-
-#define malloc xmalloc
-#define realloc xrealloc
-
-#include "gengtype.h"
-
-#define YY_DECL int yylex (const char **yylval)
-#define yyterminate() return EOF_TOKEN
-
-struct fileloc lexer_line;
-int lexer_toplevel_done;
-
-static void 
-update_lineno (const char *l, size_t len)
-{
-  while (len-- > 0)
-    if (*l++ == '\n')
-      lexer_line.line++;
-}
-
-/* Include '::' in identifiers to capture C++ scope qualifiers.  */
-
-#line 1242 "gengtype-lex.c"
-
-#define INITIAL 0
-#define in_struct 1
-#define in_struct_comment 2
-#define in_comment 3
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals (void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy (void );
-
-int yyget_debug (void );
-
-void yyset_debug (int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra (void );
-
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in (void );
-
-void yyset_in  (FILE * _in_str  );
-
-FILE *yyget_out (void );
-
-void yyset_out  (FILE * _out_str  );
-
-			int yyget_leng (void );
-
-char *yyget_text (void );
-
-int yyget_lineno (void );
-
-void yyset_lineno (int _line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-    
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
-#endif
-
-#ifndef YY_NO_INPUT
-
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		int n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
-#endif
-
-#define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
-    
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state( );
-		}
-
-	{
-#line 66 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-
-  /* Do this on entry to yylex():  */
-  *yylval = 0;
-  if (lexer_toplevel_done)
-    {
-      BEGIN(INITIAL);
-      lexer_toplevel_done = 0;
-    }
-
-  /* Things we look for in skipping mode: */
-#line 1475 "gengtype-lex.c"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-		yy_current_state += YY_AT_BOL();
-yy_match:
-		do
-			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 561 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
-			++yy_cp;
-			}
-		while ( yy_current_state != 560 );
-		yy_cp = (yy_last_accepting_cpos);
-		yy_current_state = (yy_last_accepting_state);
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-/* rule 1 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 77 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return TYPEDEF;
-}
-	YY_BREAK
-case 2:
-/* rule 2 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 81 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STRUCT;
-}
-	YY_BREAK
-case 3:
-/* rule 3 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 85 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return UNION;
-}
-	YY_BREAK
-case 4:
-/* rule 4 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 89 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STRUCT;
-}
-	YY_BREAK
-case 5:
-/* rule 5 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 93 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return EXTERN;
-}
-	YY_BREAK
-case 6:
-/* rule 6 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 97 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  BEGIN(in_struct);
-  return STATIC;
-}
-	YY_BREAK
-
-/* Parsing inside a struct, union or class declaration.  */
-
-case 7:
-YY_RULE_SETUP
-#line 105 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ BEGIN(in_struct_comment); }
-	YY_BREAK
-case 8:
-/* rule 8 can match eol */
-YY_RULE_SETUP
-#line 106 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 9:
-/* rule 9 can match eol */
-YY_RULE_SETUP
-#line 108 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ update_lineno (yytext, yyleng); }
-	YY_BREAK
-case 10:
-/* rule 10 can match eol */
-YY_RULE_SETUP
-#line 109 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 11:
-/* rule 11 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 5);
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 111 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* don't care */
-	YY_BREAK
-case 12:
-/* rule 12 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-#line 113 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 13:
-/* rule 13 can match eol */
-#line 114 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 14:
-/* rule 14 can match eol */
-#line 115 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 15:
-/* rule 15 can match eol */
-YY_RULE_SETUP
-#line 115 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-    *yylval = XDUPVAR (const char, yytext, yyleng, yyleng + 1);
-    return IGNORABLE_CXX_KEYWORD;
-}
-	YY_BREAK
-case 16:
-/* rule 16 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 3);
-(yy_c_buf_p) = yy_cp = yy_bp + 3;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 119 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return GTY_TOKEN; }
-	YY_BREAK
-case 17:
-/* rule 17 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 5);
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 120 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return UNION; }
-	YY_BREAK
-case 18:
-/* rule 18 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 6);
-(yy_c_buf_p) = yy_cp = yy_bp + 6;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 121 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return STRUCT; }
-	YY_BREAK
-case 19:
-/* rule 19 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 5);
-(yy_c_buf_p) = yy_cp = yy_bp + 5;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 122 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return STRUCT; }
-	YY_BREAK
-case 20:
-/* rule 20 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 7);
-(yy_c_buf_p) = yy_cp = yy_bp + 7;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 123 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return TYPEDEF; }
-	YY_BREAK
-case 21:
-/* rule 21 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 4);
-(yy_c_buf_p) = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 124 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return ENUM; }
-	YY_BREAK
-case 22:
-/* rule 22 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 9);
-(yy_c_buf_p) = yy_cp = yy_bp + 9;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 125 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return PTR_ALIAS; }
-	YY_BREAK
-case 23:
-/* rule 23 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 10);
-(yy_c_buf_p) = yy_cp = yy_bp + 10;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 126 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return NESTED_PTR; }
-	YY_BREAK
-case 24:
-/* rule 24 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 4);
-(yy_c_buf_p) = yy_cp = yy_bp + 4;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 127 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return USER_GTY; }
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 128 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return NUM; }
-	YY_BREAK
-case 26:
-/* rule 26 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-#line 131 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 27:
-/* rule 27 can match eol */
-YY_RULE_SETUP
-#line 131 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  size_t len;
-
-  for (len = yyleng; ISSPACE (yytext[len-1]); len--)
-    ;
-
-  *yylval = XDUPVAR (const char, yytext, len, len+1);
-  update_lineno (yytext, yyleng);
-  return SCALAR;
-}
-	YY_BREAK
-case 28:
-/* rule 28 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_cp - 1);
-(yy_c_buf_p) = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 142 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);
-  return ID;
-}
-	YY_BREAK
-case 29:
-/* rule 29 can match eol */
-YY_RULE_SETUP
-#line 147 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);
-  return STRING;
-}
-	YY_BREAK
-/* This "terminal" avoids having to parse integer constant expressions.  */
-case 30:
-/* rule 30 can match eol */
-YY_RULE_SETUP
-#line 152 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng-1);
-  return ARRAY;
-}
-	YY_BREAK
-case 31:
-/* rule 31 can match eol */
-YY_RULE_SETUP
-#line 156 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  *yylval = XDUPVAR (const char, yytext+1, yyleng-2, yyleng);
-  return CHAR;
-}
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 161 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return ELLIPSIS; }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 162 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ return yytext[0]; }
-	YY_BREAK
-/* ignore pp-directives */
-case 34:
-/* rule 34 can match eol */
-YY_RULE_SETUP
-#line 165 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{lexer_line.line++;}
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 167 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, "unexpected character `%s'", yytext);
-}
-	YY_BREAK
-
-case 36:
-YY_RULE_SETUP
-#line 172 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ BEGIN(in_comment); }
-	YY_BREAK
-case 37:
-/* rule 37 can match eol */
-YY_RULE_SETUP
-#line 173 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 38:
-/* rule 38 can match eol */
-YY_RULE_SETUP
-#line 174 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 39:
-#line 176 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 40:
-/* rule 40 can match eol */
-#line 177 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 41:
-/* rule 41 can match eol */
-YY_RULE_SETUP
-#line 177 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 42:
-/* rule 42 can match eol */
-YY_RULE_SETUP
-#line 178 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ update_lineno (yytext, yyleng); }
-	YY_BREAK
-case 43:
-/* rule 43 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 1);
-(yy_c_buf_p) = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 179 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-
-case 44:
-/* rule 44 can match eol */
-YY_RULE_SETUP
-#line 182 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ lexer_line.line++; }
-	YY_BREAK
-case 45:
-#line 184 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 46:
-YY_RULE_SETUP
-#line 184 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 47:
-/* rule 47 can match eol */
-*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
-YY_LINENO_REWIND_TO(yy_bp + 1);
-(yy_c_buf_p) = yy_cp = yy_bp + 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
-YY_RULE_SETUP
-#line 185 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-
-case 48:
-YY_RULE_SETUP
-#line 188 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ BEGIN(INITIAL); } 
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 189 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{ BEGIN(in_struct); }
-	YY_BREAK
-case 50:
-#line 192 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-case 51:
-YY_RULE_SETUP
-#line 192 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-{
-  error_at_line (&lexer_line, 
-		 "unterminated comment or string; unexpected EOF");
-}
-	YY_BREAK
-case 52:
-/* rule 52 can match eol */
-YY_RULE_SETUP
-#line 197 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-/* do nothing */
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 199 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-YY_FATAL_ERROR( "flex scanner jammed" );
-	YY_BREAK
-#line 1948 "gengtype-lex.c"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(in_struct):
-case YY_STATE_EOF(in_struct_comment):
-case YY_STATE_EOF(in_comment):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_last_accepting_cpos);
-				yy_current_state = (yy_last_accepting_state);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap( ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of user's declarations */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = (yytext_ptr);
-	yy_size_t number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (yy_size_t) ((yy_c_buf_p) - (yytext_ptr)) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,(yy_size_t) (b->yy_buf_size + 2)  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = NULL;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((int) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,(yy_size_t) new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	yy_state_type yy_current_state;
-	char *yy_cp;
-    
-	yy_current_state = (yy_start);
-	yy_current_state += YY_AT_BOL();
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 561 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	int yy_is_jam;
-    	char *yy_cp = (yy_c_buf_p);
-
-	YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 561 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
-	yy_is_jam = (yy_current_state == 560);
-
-		return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_UNPUT
-
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
-	}
-
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc((yy_size_t) (b->yy_buf_size + 2)  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer(b,file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
-
-	yyfree((void *) b  );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer(b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	int num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return NULL;
-
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer(b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,(int) strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	yy_size_t i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yynoreturn yy_fatal_error (yyconst char* msg )
-{
-			(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        yy_size_t yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param _line_number line number
- * 
- */
-void yyset_lineno (int  _line_number )
-{
-    
-    yylineno = _line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param _in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  _in_str )
-{
-        yyin = _in_str ;
-}
-
-void yyset_out (FILE *  _out_str )
-{
-        yyout = _out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  _bdebug )
-{
-        yy_flex_debug = _bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = NULL;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = NULL;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = NULL;
-    yyout = NULL;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
-{
-		
-	int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
-{
-	int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-			return malloc(size);
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-		
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return realloc(ptr, size);
-}
-
-void yyfree (void * ptr )
-{
-			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 199 "/d/gcc-8.2.0/gcc-8.2.0/gcc/gengtype-lex.l"
-
-
-
-void
-yybegin (const char *fname)
-{
-  yyin = fopen (fname, "r");
-  if (yyin == NULL)
-    {
-      perror (fname);
-      exit (1);
-    }
-  lexer_line.file = input_file_by_name (fname);
-  lexer_line.line = 1;
-}
-
-void
-yyend (void)
-{
-  fclose (yyin);
-}
-
diff -Naur gcc-8.2.0/gcc/genmatch.c gcc-8-20181012/gcc/genmatch.c
--- gcc-8.2.0/gcc/genmatch.c	2018-02-28 16:40:41.000000000 +0300
+++ gcc-8-20181012/gcc/genmatch.c	2018-07-29 19:44:24.000000000 +0300
@@ -2680,12 +2680,14 @@
   char match_opname[20];
   match_dop->get_name (match_opname);
   if (value_match)
-    fprintf_indent (f, indent, "if (%s == %s || operand_equal_p (%s, %s, 0))\n",
-		    opname, match_opname, opname, match_opname);
+    fprintf_indent (f, indent, "if ((%s == %s && ! TREE_SIDE_EFFECTS (%s)) "
+		    "|| operand_equal_p (%s, %s, 0))\n",
+		    opname, match_opname, opname, opname, match_opname);
   else
-    fprintf_indent (f, indent, "if (%s == %s || (operand_equal_p (%s, %s, 0) "
+    fprintf_indent (f, indent, "if ((%s == %s && ! TREE_SIDE_EFFECTS (%s)) "
+		    "|| (operand_equal_p (%s, %s, 0) "
 		    "&& types_match (%s, %s)))\n",
-		    opname, match_opname, opname, match_opname,
+		    opname, match_opname, opname, opname, match_opname,
 		    opname, match_opname);
   fprintf_indent (f, indent + 2, "{\n");
   return 1;
diff -Naur gcc-8.2.0/gcc/gimple-loop-jam.c gcc-8-20181012/gcc/gimple-loop-jam.c
--- gcc-8.2.0/gcc/gimple-loop-jam.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/gimple-loop-jam.c	2018-09-01 20:33:45.000000000 +0300
@@ -161,7 +161,7 @@
   gimple_stmt_iterator gsi;
   /* BB is duplicated by outer unrolling and then all N-1 first copies
      move into the body of the fused inner loop.  If BB exits the outer loop
-     the last copy still doess so, and the first N-1 copies are cancelled
+     the last copy still does so, and the first N-1 copies are cancelled
      by loop unrolling, so also after fusion it's the exit block.
      But there might be other reasons that prevent fusion:
        * stores or unknown side-effects prevent fusion
@@ -227,6 +227,33 @@
       || !expr_invariant_in_loop_p (outer, niter.niter))
     return false;
 
+  /* If the inner loop produces any values that are used inside the
+     outer loop (except the virtual op) then it can flow
+     back (perhaps indirectly) into the inner loop.  This prevents
+     fusion: without fusion the value at the last iteration is used,
+     with fusion the value after the initial iteration is used.
+
+     If all uses are outside the outer loop this doesn't prevent fusion;
+     the value of the last iteration is still used (and the values from
+     all intermediate iterations are dead).  */
+  gphi_iterator psi;
+  for (psi = gsi_start_phis (single_exit (loop)->dest);
+       !gsi_end_p (psi); gsi_next (&psi))
+    {
+      imm_use_iterator imm_iter;
+      use_operand_p use_p;
+      tree op = gimple_phi_result (psi.phi ());
+      if (virtual_operand_p (op))
+	continue;
+      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)
+	{
+	  gimple *use_stmt = USE_STMT (use_p);
+	  if (!is_gimple_debug (use_stmt)
+	      && flow_bb_inside_loop_p (outer, gimple_bb (use_stmt)))
+	    return false;
+	}
+    }
+
   /* And check blocks belonging to just outer loop.  */
   bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));
   n = get_loop_body_with_size (outer, bbs, n_basic_blocks_for_fn (cfun));
@@ -245,7 +272,6 @@
      body would be the after-iter value of the first body) if it's over
      an associative and commutative operation.  We wouldn't
      be able to handle unknown cycles.  */
-  gphi_iterator psi;
   for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))
     {
       affine_iv iv;
diff -Naur gcc-8.2.0/gcc/gimple-ssa-store-merging.c gcc-8-20181012/gcc/gimple-ssa-store-merging.c
--- gcc-8.2.0/gcc/gimple-ssa-store-merging.c	2018-07-12 10:46:04.000000000 +0300
+++ gcc-8-20181012/gcc/gimple-ssa-store-merging.c	2018-10-11 20:39:46.000000000 +0300
@@ -2648,15 +2648,80 @@
 	{
 	  /* Only allow overlapping stores of constants.  */
 	  if (info->rhs_code == INTEGER_CST
-	      && merged_store->stores[0]->rhs_code == INTEGER_CST
-	      && check_no_overlap (m_store_info, i, INTEGER_CST,
-				   MAX (merged_store->last_order, info->order),
-				   MAX (merged_store->start
-					+ merged_store->width,
-					info->bitpos + info->bitsize)))
+	      && merged_store->stores[0]->rhs_code == INTEGER_CST)
 	    {
-	      merged_store->merge_overlapping (info);
-	      continue;
+	      unsigned int last_order
+		= MAX (merged_store->last_order, info->order);
+	      unsigned HOST_WIDE_INT end
+		= MAX (merged_store->start + merged_store->width,
+		       info->bitpos + info->bitsize);
+	      if (check_no_overlap (m_store_info, i, INTEGER_CST,
+				    last_order, end))
+		{
+		  /* check_no_overlap call above made sure there are no
+		     overlapping stores with non-INTEGER_CST rhs_code
+		     in between the first and last of the stores we've
+		     just merged.  If there are any INTEGER_CST rhs_code
+		     stores in between, we need to merge_overlapping them
+		     even if in the sort_by_bitpos order there are other
+		     overlapping stores in between.  Keep those stores as is.
+		     Example:
+			MEM[(int *)p_28] = 0;
+			MEM[(char *)p_28 + 3B] = 1;
+			MEM[(char *)p_28 + 1B] = 2;
+			MEM[(char *)p_28 + 2B] = MEM[(char *)p_28 + 6B];
+		     We can't merge the zero store with the store of two and
+		     not merge anything else, because the store of one is
+		     in the original order in between those two, but in
+		     store_by_bitpos order it comes after the last store that
+		     we can't merge with them.  We can merge the first 3 stores
+		     and keep the last store as is though.  */
+		  unsigned int len = m_store_info.length (), k = i;
+		  for (unsigned int j = i + 1; j < len; ++j)
+		    {
+		      store_immediate_info *info2 = m_store_info[j];
+		      if (info2->bitpos >= end)
+			break;
+		      if (info2->order < last_order)
+			{
+			  if (info2->rhs_code != INTEGER_CST)
+			    {
+			      /* Normally check_no_overlap makes sure this
+				 doesn't happen, but if end grows below, then
+				 we need to process more stores than
+				 check_no_overlap verified.  Example:
+				    MEM[(int *)p_5] = 0;
+				    MEM[(short *)p_5 + 3B] = 1;
+				    MEM[(char *)p_5 + 4B] = _9;
+				    MEM[(char *)p_5 + 2B] = 2;  */
+			      k = 0;
+			      break;
+			    }
+			  k = j;
+			  end = MAX (end, info2->bitpos + info2->bitsize);
+			}
+		    }
+
+		  if (k != 0)
+		    {
+		      merged_store->merge_overlapping (info);
+
+		      for (unsigned int j = i + 1; j <= k; j++)
+			{
+			  store_immediate_info *info2 = m_store_info[j];
+			  gcc_assert (info2->bitpos < end);
+			  if (info2->order < last_order)
+			    {
+			      gcc_assert (info2->rhs_code == INTEGER_CST);
+			      merged_store->merge_overlapping (info2);
+			    }
+			  /* Other stores are kept and not merged in any
+			     way.  */
+			}
+		      ignore = k;
+		      continue;
+		    }
+		}
 	    }
 	}
       /* |---store 1---||---store 2---|
diff -Naur gcc-8.2.0/gcc/gimplify.c gcc-8-20181012/gcc/gimplify.c
--- gcc-8.2.0/gcc/gimplify.c	2018-06-19 12:44:33.000000000 +0300
+++ gcc-8-20181012/gcc/gimplify.c	2018-07-26 19:32:51.000000000 +0300
@@ -9734,9 +9734,26 @@
 	  t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), i);
 	  if (!is_gimple_constant (TREE_OPERAND (t, 1)))
 	    {
+	      tree type = TREE_TYPE (TREE_OPERAND (t, 0));
 	      TREE_OPERAND (t, 1)
 		= get_initialized_tmp_var (TREE_OPERAND (t, 1),
-					   pre_p, NULL, false);
+					   gimple_seq_empty_p (for_pre_body)
+					   ? pre_p : &for_pre_body, NULL,
+					   false);
+	      /* Reference to pointer conversion is considered useless,
+		 but is significant for firstprivate clause.  Force it
+		 here.  */
+	      if (TREE_CODE (type) == POINTER_TYPE
+		  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 1)))
+		      == REFERENCE_TYPE))
+		{
+		  tree v = create_tmp_var (TYPE_MAIN_VARIANT (type));
+		  tree m = build2 (INIT_EXPR, TREE_TYPE (v), v,
+				   TREE_OPERAND (t, 1));
+		  gimplify_and_add (m, gimple_seq_empty_p (for_pre_body)
+				       ? pre_p : &for_pre_body);
+		  TREE_OPERAND (t, 1) = v;
+		}
 	      tree c = build_omp_clause (input_location,
 					 OMP_CLAUSE_FIRSTPRIVATE);
 	      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);
@@ -9748,11 +9765,26 @@
 	  t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), i);
 	  if (!is_gimple_constant (TREE_OPERAND (t, 1)))
 	    {
+	      tree type = TREE_TYPE (TREE_OPERAND (t, 0));
 	      TREE_OPERAND (t, 1)
 		= get_initialized_tmp_var (TREE_OPERAND (t, 1),
 					   gimple_seq_empty_p (for_pre_body)
 					   ? pre_p : &for_pre_body, NULL,
 					   false);
+	      /* Reference to pointer conversion is considered useless,
+		 but is significant for firstprivate clause.  Force it
+		 here.  */
+	      if (TREE_CODE (type) == POINTER_TYPE
+		  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 1)))
+		      == REFERENCE_TYPE))
+		{
+		  tree v = create_tmp_var (TYPE_MAIN_VARIANT (type));
+		  tree m = build2 (INIT_EXPR, TREE_TYPE (v), v,
+				   TREE_OPERAND (t, 1));
+		  gimplify_and_add (m, gimple_seq_empty_p (for_pre_body)
+				       ? pre_p : &for_pre_body);
+		  TREE_OPERAND (t, 1) = v;
+		}
 	      tree c = build_omp_clause (input_location,
 					 OMP_CLAUSE_FIRSTPRIVATE);
 	      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);
diff -Naur gcc-8.2.0/gcc/graphite.h gcc-8-20181012/gcc/graphite.h
--- gcc-8.2.0/gcc/graphite.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/graphite.h	2018-08-01 11:06:20.000000000 +0300
@@ -37,6 +37,8 @@
 #include <isl/schedule.h>
 #include <isl/ast_build.h>
 #include <isl/schedule_node.h>
+#include <isl/id.h>
+#include <isl/space.h>
 
 typedef struct poly_dr *poly_dr_p;
 
diff -Naur gcc-8.2.0/gcc/match.pd gcc-8-20181012/gcc/match.pd
--- gcc-8.2.0/gcc/match.pd	2018-07-16 14:01:48.000000000 +0300
+++ gcc-8-20181012/gcc/match.pd	2018-09-15 02:30:32.000000000 +0300
@@ -3462,8 +3462,8 @@
        /* Disable this optimization if we're casting a function pointer
 	  type on targets that require function pointer canonicalization.  */
        && !(targetm.have_canonicalize_funcptr_for_compare ()
-	    && TREE_CODE (TREE_TYPE (@00)) == POINTER_TYPE
-	    && TREE_CODE (TREE_TYPE (TREE_TYPE (@00))) == FUNCTION_TYPE)
+	    && POINTER_TYPE_P (TREE_TYPE (@00))
+	    && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@00))))
        && single_use (@0))
    (if (TYPE_PRECISION (TREE_TYPE (@00)) == TYPE_PRECISION (TREE_TYPE (@0))
 	&& (TREE_CODE (@10) == INTEGER_CST
diff -Naur gcc-8.2.0/gcc/omp-low.c gcc-8-20181012/gcc/omp-low.c
--- gcc-8.2.0/gcc/omp-low.c	2018-02-10 02:22:43.000000000 +0300
+++ gcc-8-20181012/gcc/omp-low.c	2018-07-26 19:36:29.000000000 +0300
@@ -1190,13 +1190,16 @@
 	  /* Global variables with "omp declare target" attribute
 	     don't need to be copied, the receiver side will use them
 	     directly.  However, global variables with "omp declare target link"
-	     attribute need to be copied.  */
+	     attribute need to be copied.  Or when ALWAYS modifier is used.  */
 	  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP
 	      && DECL_P (decl)
 	      && ((OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FIRSTPRIVATE_POINTER
 		   && (OMP_CLAUSE_MAP_KIND (c)
 		       != GOMP_MAP_FIRSTPRIVATE_REFERENCE))
 		  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)
+	      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TO
+	      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_FROM
+	      && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_TOFROM
 	      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))
 	      && varpool_node::get_create (decl)->offloadable
 	      && !lookup_attribute ("omp declare target link",
@@ -7099,6 +7102,7 @@
   splay_tree_node n;
   struct omp_taskcopy_context tcctx;
   location_t loc = gimple_location (task_stmt);
+  size_t looptempno = 0;
 
   child_fn = gimple_omp_task_copy_fn (task_stmt);
   child_cfun = DECL_STRUCT_FUNCTION (child_fn);
@@ -7212,6 +7216,15 @@
 	t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);
 	append_to_statement_list (t, &list);
 	break;
+      case OMP_CLAUSE__LOOPTEMP_:
+	/* Fields for first two _looptemp_ clauses are initialized by
+	   GOMP_taskloop*, the rest are handled like firstprivate.  */
+        if (looptempno < 2)
+	  {
+	    looptempno++;
+	    break;
+	  }
+	/* FALLTHRU */
       case OMP_CLAUSE_FIRSTPRIVATE:
 	decl = OMP_CLAUSE_DECL (c);
 	if (is_variable_sized (decl))
@@ -7237,7 +7250,10 @@
 	  src = decl;
 	dst = build_simple_mem_ref_loc (loc, arg);
 	dst = omp_build_component_ref (dst, f);
-	t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);
+	if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE__LOOPTEMP_)
+	  t = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);
+	else
+	  t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);
 	append_to_statement_list (t, &list);
 	break;
       case OMP_CLAUSE_PRIVATE:
diff -Naur gcc-8.2.0/gcc/pretty-print.c gcc-8-20181012/gcc/pretty-print.c
--- gcc-8.2.0/gcc/pretty-print.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/gcc/pretty-print.c	2018-08-14 13:17:27.000000000 +0300
@@ -640,6 +640,16 @@
 	{
 	  attrib_add |= sb.wAttributes & ~attrib_rm;
 	}
+      if (attrib_add & COMMON_LVB_REVERSE_VIDEO)
+	{
+	  /* COMMON_LVB_REVERSE_VIDEO is only effective for DBCS.
+	   * Swap foreground and background colors by hand.
+	   */
+	  attrib_add = (attrib_add & 0xFF00)
+			| ((attrib_add & 0x00F0) >> 4)
+			| ((attrib_add & 0x000F) << 4);
+	  attrib_add &= ~COMMON_LVB_REVERSE_VIDEO;
+	}
       SetConsoleTextAttribute (h, attrib_add);
       break;
     }
@@ -684,7 +694,6 @@
     /* If it is not a console, write everything as-is.  */
     write_all (h, read, strlen (read));
 
-  _close ((intptr_t) h);
   return 1;
 }
 
diff -Naur gcc-8.2.0/gcc/rtlanal.c gcc-8-20181012/gcc/rtlanal.c
--- gcc-8.2.0/gcc/rtlanal.c	2018-02-16 11:20:32.000000000 +0300
+++ gcc-8-20181012/gcc/rtlanal.c	2018-09-18 19:24:58.000000000 +0300
@@ -1802,6 +1802,7 @@
  recurse:
   switch (GET_CODE (x))
     {
+    case CLOBBER:
     case STRICT_LOW_PART:
     case ZERO_EXTRACT:
     case SIGN_EXTRACT:
diff -Naur gcc-8.2.0/gcc/stor-layout.c gcc-8-20181012/gcc/stor-layout.c
--- gcc-8.2.0/gcc/stor-layout.c	2018-02-28 20:17:29.000000000 +0300
+++ gcc-8-20181012/gcc/stor-layout.c	2018-09-05 13:42:59.000000000 +0300
@@ -1685,14 +1685,21 @@
     {
       rli->bitpos = size_binop (PLUS_EXPR, rli->bitpos, DECL_SIZE (field));
 
-      /* If we ended a bitfield before the full length of the type then
-	 pad the struct out to the full length of the last type.  */
-      if ((DECL_CHAIN (field) == NULL
-	   || TREE_CODE (DECL_CHAIN (field)) != FIELD_DECL)
-	  && DECL_BIT_FIELD_TYPE (field)
+      /* If FIELD is the last field and doesn't end at the full length
+	 of the type then pad the struct out to the full length of the
+	 last type.  */
+      if (DECL_BIT_FIELD_TYPE (field)
 	  && !integer_zerop (DECL_SIZE (field)))
-	rli->bitpos = size_binop (PLUS_EXPR, rli->bitpos,
-				  bitsize_int (rli->remaining_in_alignment));
+	{
+	  /* We have to scan, because non-field DECLS are also here.  */
+	  tree probe = field;
+	  while ((probe = DECL_CHAIN (probe)))
+	    if (TREE_CODE (probe) == FIELD_DECL)
+	      break;
+	  if (!probe)
+	    rli->bitpos = size_binop (PLUS_EXPR, rli->bitpos,
+				      bitsize_int (rli->remaining_in_alignment));
+	}
 
       normalize_rli (rli);
     }
diff -Naur gcc-8.2.0/gcc/tree.c gcc-8-20181012/gcc/tree.c
--- gcc-8.2.0/gcc/tree.c	2018-06-14 15:31:46.000000000 +0300
+++ gcc-8-20181012/gcc/tree.c	2018-08-25 15:10:28.000000000 +0300
@@ -9784,8 +9784,7 @@
       TYPE_SIZE (int_n_trees[i].signed_type) = bitsize_int (int_n_data[i].bitsize);
       TYPE_SIZE (int_n_trees[i].unsigned_type) = bitsize_int (int_n_data[i].bitsize);
 
-      if (int_n_data[i].bitsize > LONG_LONG_TYPE_SIZE
-	  && int_n_enabled_p[i])
+      if (int_n_enabled_p[i])
 	{
 	  integer_types[itk_intN_0 + i * 2] = int_n_trees[i].signed_type;
 	  integer_types[itk_unsigned_intN_0 + i * 2] = int_n_trees[i].unsigned_type;
diff -Naur gcc-8.2.0/gcc/tree.h gcc-8-20181012/gcc/tree.h
--- gcc-8.2.0/gcc/tree.h	2018-03-16 15:46:12.000000000 +0300
+++ gcc-8-20181012/gcc/tree.h	2018-10-03 12:24:38.000000000 +0300
@@ -3061,6 +3061,10 @@
 #define DECL_CXX_DESTRUCTOR_P(NODE)\
    (FUNCTION_DECL_CHECK (NODE)->decl_with_vis.cxx_destructor)
 
+/* In FUNCTION_DECL, this is set if this function is a lambda function.  */
+#define DECL_LAMBDA_FUNCTION(NODE) \
+  (FUNCTION_DECL_CHECK (NODE)->function_decl.lambda_function)
+
 /* In FUNCTION_DECL that represent an virtual method this is set when
    the method is final.  */
 #define DECL_FINAL_P(NODE)\
diff -Naur gcc-8.2.0/gcc/tree-cfg.c gcc-8-20181012/gcc/tree-cfg.c
--- gcc-8.2.0/gcc/tree-cfg.c	2018-07-16 14:01:48.000000000 +0300
+++ gcc-8-20181012/gcc/tree-cfg.c	2018-08-31 11:33:14.000000000 +0300
@@ -9297,20 +9297,16 @@
   tree type = TREE_TYPE (index);
   tree utype = unsigned_type_for (type);
 
-  low = fold_convert (type, low);
-  high = fold_convert (type, high);
+  low = fold_convert (utype, low);
+  high = fold_convert (utype, high);
 
-  tree tmp = make_ssa_name (type);
-  gassign *sub1
-    = gimple_build_assign (tmp, MINUS_EXPR, index, low);
+  gimple_seq seq = NULL;
+  index = gimple_convert (&seq, utype, index);
+  *lhs = gimple_build (&seq, MINUS_EXPR, utype, index, low);
+  *rhs = const_binop (MINUS_EXPR, utype, high, low);
 
-  *lhs = make_ssa_name (utype);
-  gassign *a = gimple_build_assign (*lhs, NOP_EXPR, tmp);
-
-  *rhs = fold_build2 (MINUS_EXPR, utype, high, low);
   gimple_stmt_iterator gsi = gsi_last_bb (bb);
-  gsi_insert_before (&gsi, sub1, GSI_SAME_STMT);
-  gsi_insert_before (&gsi, a, GSI_SAME_STMT);
+  gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);
 }
 
 /* Emit return warnings.  */
diff -Naur gcc-8.2.0/gcc/tree-core.h gcc-8-20181012/gcc/tree-core.h
--- gcc-8.2.0/gcc/tree-core.h	2018-01-12 17:45:35.000000000 +0300
+++ gcc-8-20181012/gcc/tree-core.h	2018-10-03 12:24:38.000000000 +0300
@@ -1796,8 +1796,8 @@
   unsigned pure_flag : 1;
   unsigned looping_const_or_pure_flag : 1;
   unsigned has_debug_args_flag : 1;
-  unsigned tm_clone_flag : 1;
   unsigned versioned_function : 1;
+  unsigned lambda_function: 1;
   /* No bits left.  */
 };
 
diff -Naur gcc-8.2.0/gcc/tree-inline.c gcc-8-20181012/gcc/tree-inline.c
--- gcc-8.2.0/gcc/tree-inline.c	2018-03-09 22:12:29.000000000 +0300
+++ gcc-8-20181012/gcc/tree-inline.c	2018-08-31 11:33:14.000000000 +0300
@@ -1961,8 +1961,7 @@
 		   && id->call_stmt
 		   && (decl = gimple_call_fndecl (stmt))
 		   && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL
-		   && DECL_FUNCTION_CODE (decl) == BUILT_IN_VA_ARG_PACK_LEN
-		   && ! gimple_call_va_arg_pack_p (id->call_stmt))
+		   && DECL_FUNCTION_CODE (decl) == BUILT_IN_VA_ARG_PACK_LEN)
 	    {
 	      /* __builtin_va_arg_pack_len () should be replaced by
 		 the number of anonymous arguments.  */
@@ -1980,10 +1979,28 @@
 		if (POINTER_BOUNDS_P (gimple_call_arg (id->call_stmt, i)))
 		  nargs--;
 
-	      count = build_int_cst (integer_type_node, nargs);
-	      new_stmt = gimple_build_assign (gimple_call_lhs (stmt), count);
-	      gsi_replace (&copy_gsi, new_stmt, false);
-	      stmt = new_stmt;
+	      if (!gimple_call_lhs (stmt))
+		{
+		  /* Drop unused calls.  */
+		  gsi_remove (&copy_gsi, false);
+		  continue;
+		}
+	      else if (!gimple_call_va_arg_pack_p (id->call_stmt))
+		{
+		  count = build_int_cst (integer_type_node, nargs);
+		  new_stmt = gimple_build_assign (gimple_call_lhs (stmt), count);
+		  gsi_replace (&copy_gsi, new_stmt, false);
+		  stmt = new_stmt;
+		}
+	      else if (nargs != 0)
+		{
+		  tree newlhs = create_tmp_reg_or_ssa_name (integer_type_node);
+		  count = build_int_cst (integer_type_node, nargs);
+		  new_stmt = gimple_build_assign (gimple_call_lhs (stmt),
+						  PLUS_EXPR, newlhs, count);
+		  gimple_call_set_lhs (stmt, newlhs);
+		  gsi_insert_after (&copy_gsi, new_stmt, GSI_NEW_STMT);
+		}
 	    }
 	  else if (call_stmt
 		   && id->call_stmt
diff -Naur gcc-8.2.0/gcc/tree-ssa-math-opts.c gcc-8-20181012/gcc/tree-ssa-math-opts.c
--- gcc-8.2.0/gcc/tree-ssa-math-opts.c	2018-01-12 17:06:10.000000000 +0300
+++ gcc-8-20181012/gcc/tree-ssa-math-opts.c	2018-09-05 10:21:15.000000000 +0300
@@ -422,6 +422,8 @@
 	    gsi_next (&gsi);
 
 	  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);
+	  if (should_insert_square_recip)
+	    gsi_insert_before (&gsi, new_square_stmt, GSI_SAME_STMT);
 	}
       else if (def_gsi && occ->bb == def_gsi->bb)
 	{
@@ -429,21 +431,19 @@
 	     never happen if the definition statement can throw, because in
 	     that case the sole successor of the statement's basic block will
 	     dominate all the uses as well.  */
-	  gsi = *def_gsi;
 	  gsi_insert_after (def_gsi, new_stmt, GSI_NEW_STMT);
+	  if (should_insert_square_recip)
+	    gsi_insert_after (def_gsi, new_square_stmt, GSI_NEW_STMT);
 	}
       else
 	{
 	  /* Case 3: insert in a basic block not containing defs/uses.  */
 	  gsi = gsi_after_labels (occ->bb);
 	  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);
+	  if (should_insert_square_recip)
+	    gsi_insert_before (&gsi, new_square_stmt, GSI_SAME_STMT);
 	}
 
-      /* Regardless of which case the reciprocal as inserted in,
-	 we insert the square immediately after the reciprocal.  */
-      if (should_insert_square_recip)
-	gsi_insert_before (&gsi, new_square_stmt, GSI_SAME_STMT);
-
       reciprocal_stats.rdivs_inserted++;
 
       occ->recip_def_stmt = new_stmt;
diff -Naur gcc-8.2.0/gcc/tree-ssa-strlen.c gcc-8-20181012/gcc/tree-ssa-strlen.c
--- gcc-8.2.0/gcc/tree-ssa-strlen.c	2018-07-18 20:20:05.000000000 +0300
+++ gcc-8-20181012/gcc/tree-ssa-strlen.c	2018-08-28 19:43:58.000000000 +0300
@@ -1182,6 +1182,7 @@
      suggests if it's treated as a poor-man's flexible array member.  */
   src = TREE_OPERAND (src, 0);
   if (TREE_CODE (TREE_TYPE (src)) != ARRAY_TYPE
+      || TREE_CODE (src) == MEM_REF
       || array_at_struct_end_p (src))
     return;
 
diff -Naur gcc-8.2.0/gcc/tree-ssa-tail-merge.c gcc-8-20181012/gcc/tree-ssa-tail-merge.c
--- gcc-8.2.0/gcc/tree-ssa-tail-merge.c	2018-03-22 13:21:12.000000000 +0300
+++ gcc-8-20181012/gcc/tree-ssa-tail-merge.c	2018-09-03 12:43:46.000000000 +0300
@@ -286,6 +286,21 @@
 #define BB_VOP_AT_EXIT(bb) (((struct aux_bb_info *)bb->aux)->vop_at_exit)
 #define BB_DEP_BB(bb) (((struct aux_bb_info *)bb->aux)->dep_bb)
 
+/* Valueization helper querying the VN lattice.  */
+
+static tree
+tail_merge_valueize (tree name)
+{
+  if (TREE_CODE (name) == SSA_NAME
+      && has_VN_INFO (name))
+    {
+      tree tem = VN_INFO (name)->valnum;
+      if (tem != VN_TOP)
+	return tem;
+    }
+  return name;
+}
+
 /* Returns true if the only effect a statement STMT has, is to define locally
    used SSA_NAMEs.  */
 
@@ -301,7 +316,15 @@
   if (gimple_vdef (stmt) != NULL_TREE
       || gimple_has_side_effects (stmt)
       || gimple_could_trap_p_1 (stmt, false, false)
-      || gimple_vuse (stmt) != NULL_TREE)
+      || gimple_vuse (stmt) != NULL_TREE
+      /* Copied from tree-ssa-ifcombine.c:bb_no_side_effects_p():
+	 const calls don't match any of the above, yet they could
+	 still have some side-effects - they could contain
+	 gimple_could_trap_p statements, like floating point
+	 exceptions or integer division by zero.  See PR70586.
+	 FIXME: perhaps gimple_has_side_effects or gimple_could_trap_p
+	 should handle this.  */
+      || is_gimple_call (stmt))
     return false;
 
   def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);
@@ -363,7 +386,7 @@
   if (val1 == val2)
     return true;
 
-  if (vn_valueize (val1) != vn_valueize (val2))
+  if (tail_merge_valueize (val1) != tail_merge_valueize (val2))
     return false;
 
   return ((TREE_CODE (val1) == SSA_NAME || CONSTANT_CLASS_P (val1))
@@ -473,7 +496,7 @@
       for (i = 0; i < gimple_call_num_args (stmt); i++)
 	{
 	  arg = gimple_call_arg (stmt, i);
-	  arg = vn_valueize (arg);
+	  arg = tail_merge_valueize (arg);
 	  inchash::add_expr (arg, hstate);
 	}
     }
@@ -1139,7 +1162,7 @@
       if (lhs1 == NULL_TREE || lhs2 == NULL_TREE)
 	return false;
       if (TREE_CODE (lhs1) == SSA_NAME && TREE_CODE (lhs2) == SSA_NAME)
-	return vn_valueize (lhs1) == vn_valueize (lhs2);
+	return tail_merge_valueize (lhs1) == tail_merge_valueize (lhs2);
       return operand_equal_p (lhs1, lhs2, 0);
 
     case GIMPLE_ASSIGN:
diff -Naur gcc-8.2.0/gcc/tree-vect-loop.c gcc-8-20181012/gcc/tree-vect-loop.c
--- gcc-8.2.0/gcc/tree-vect-loop.c	2018-04-24 15:18:26.000000000 +0300
+++ gcc-8-20181012/gcc/tree-vect-loop.c	2018-08-31 11:33:14.000000000 +0300
@@ -5558,6 +5558,9 @@
 	  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)
 	      == INTEGER_INDUC_COND_REDUCTION)
 	    code = induc_code;
+	  else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)
+		   == CONST_COND_REDUCTION)
+	    code = STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info);
 	  else
 	    code = MAX_EXPR;
 	}
diff -Naur gcc-8.2.0/gcc/tree-vect-stmts.c gcc-8-20181012/gcc/tree-vect-stmts.c
--- gcc-8.2.0/gcc/tree-vect-stmts.c	2018-06-06 18:06:50.000000000 +0300
+++ gcc-8-20181012/gcc/tree-vect-stmts.c	2018-09-05 12:40:35.000000000 +0300
@@ -3745,7 +3745,7 @@
 	dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
 			 "not considering SIMD clones; not yet supported"
 			 " for variable-width vectors.\n");
-      return NULL;
+      return false;
     }
 
   unsigned int badness = 0;
@@ -9602,7 +9602,7 @@
       if (gimple_code (stmt) == GIMPLE_PHI)
         scalar_dest = PHI_RESULT (stmt);
       else
-        scalar_dest = gimple_assign_lhs (stmt);
+        scalar_dest = gimple_get_lhs (stmt);
 
       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, scalar_dest)
        {
diff -Naur gcc-8.2.0/libgcc/config/i386/shadow-stack-unwind.h gcc-8-20181012/libgcc/config/i386/shadow-stack-unwind.h
--- gcc-8.2.0/libgcc/config/i386/shadow-stack-unwind.h	2018-04-19 20:05:39.000000000 +0300
+++ gcc-8-20181012/libgcc/config/i386/shadow-stack-unwind.h	2018-10-03 19:55:06.000000000 +0300
@@ -49,8 +49,3 @@
 	}					\
     }						\
     while (0)
-
-/* Increment frame count.  Skip signal frames.  */
-#undef _Unwind_Frames_Increment
-#define _Unwind_Frames_Increment(context, frames) \
-  if (!_Unwind_IsSignalFrame (context)) frames++
diff -Naur gcc-8.2.0/libgcc/config/pa/linux-atomic.c gcc-8-20181012/libgcc/config/pa/linux-atomic.c
--- gcc-8.2.0/libgcc/config/pa/linux-atomic.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libgcc/config/pa/linux-atomic.c	2018-08-18 01:51:44.000000000 +0300
@@ -28,14 +28,9 @@
 #define EBUSY   16
 #define ENOSYS 251 
 
-/* All PA-RISC implementations supported by linux have strongly
-   ordered loads and stores.  Only cache flushes and purges can be
-   delayed.  The data cache implementations are all globally
-   coherent.  Thus, there is no need to synchonize memory accesses.
-
-   GCC automatically issues a asm memory barrier when it encounters
-   a __sync_synchronize builtin.  Thus, we do not need to define this
-   builtin.
+/* PA-RISC 2.0 supports out-of-order execution for loads and stores.
+   Thus, we need to synchonize memory accesses.  For more info, see:
+   "Advanced Performance Features of the 64-bit PA-8000" by Doug Hunt.
 
    We implement byte, short and int versions of each atomic operation
    using the kernel helper defined below.  There is no support for
@@ -119,7 +114,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -156,7 +151,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -193,7 +188,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -215,7 +210,7 @@
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -241,7 +236,7 @@
 									\
     while (1)								\
       {									\
-	actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);	\
+	actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);	\
 									\
 	if (__builtin_expect (oldval != actual_oldval, 0))		\
 	  return actual_oldval;						\
@@ -273,7 +268,7 @@
     
   while (1)
     {
-      actual_oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+      actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
 
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
@@ -300,7 +295,7 @@
     long failure;							\
 									\
     do {								\
-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);			\
+      oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);		\
     } while (failure != 0);						\
 									\
@@ -318,38 +313,31 @@
   int oldval;
 
   do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
+    oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
     failure = __kernel_cmpxchg (ptr, oldval, val);
   } while (failure != 0);
 
   return oldval;
 }
 
-#define SYNC_LOCK_RELEASE_2(TYPE, WIDTH, INDEX)			\
+void HIDDEN
+__sync_lock_release_8 (long long *ptr)
+{
+  /* All accesses must be complete before we release the lock.  */
+  __sync_synchronize ();
+  *(double *)ptr = 0;
+}
+
+#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH)			\
   void HIDDEN							\
   __sync_lock_release_##WIDTH (TYPE *ptr)			\
   {								\
-    TYPE oldval, zero = 0;					\
-    long failure;						\
-								\
-    do {							\
-      oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);		\
-      failure = __kernel_cmpxchg2 (ptr, &oldval, &zero, INDEX);	\
-    } while (failure != 0);					\
+    /* All accesses must be complete before we release		\
+       the lock.  */						\
+    __sync_synchronize ();					\
+    *ptr = 0;							\
   }
 
-SYNC_LOCK_RELEASE_2 (long long, 8, 3)
-SYNC_LOCK_RELEASE_2 (short, 2, 1)
-SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
-
-void HIDDEN
-__sync_lock_release_4 (int *ptr)
-{
-  long failure;
-  int oldval;
-
-  do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_SEQ_CST);
-    failure = __kernel_cmpxchg (ptr, oldval, 0);
-  } while (failure != 0);
-}
+SYNC_LOCK_RELEASE_1 (int, 4)
+SYNC_LOCK_RELEASE_1 (short, 2)
+SYNC_LOCK_RELEASE_1 (signed char, 1)
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_c10.c gcc-8-20181012/libgfortran/generated/matmul_c10.c
--- gcc-8.2.0/libgfortran/generated/matmul_c10.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_c10.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_c16.c gcc-8-20181012/libgfortran/generated/matmul_c16.c
--- gcc-8.2.0/libgfortran/generated/matmul_c16.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_c16.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_c4.c gcc-8-20181012/libgfortran/generated/matmul_c4.c
--- gcc-8.2.0/libgfortran/generated/matmul_c4.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_c4.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_c8.c gcc-8-20181012/libgfortran/generated/matmul_c8.c
--- gcc-8.2.0/libgfortran/generated/matmul_c8.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_c8.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_i1.c gcc-8-20181012/libgfortran/generated/matmul_i1.c
--- gcc-8.2.0/libgfortran/generated/matmul_i1.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_i1.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_i16.c gcc-8-20181012/libgfortran/generated/matmul_i16.c
--- gcc-8.2.0/libgfortran/generated/matmul_i16.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_i16.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_i2.c gcc-8-20181012/libgfortran/generated/matmul_i2.c
--- gcc-8.2.0/libgfortran/generated/matmul_i2.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_i2.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_i4.c gcc-8-20181012/libgfortran/generated/matmul_i4.c
--- gcc-8.2.0/libgfortran/generated/matmul_i4.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_i4.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_i8.c gcc-8-20181012/libgfortran/generated/matmul_i8.c
--- gcc-8.2.0/libgfortran/generated/matmul_i8.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_i8.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_r10.c gcc-8-20181012/libgfortran/generated/matmul_r10.c
--- gcc-8.2.0/libgfortran/generated/matmul_r10.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_r10.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_r16.c gcc-8-20181012/libgfortran/generated/matmul_r16.c
--- gcc-8.2.0/libgfortran/generated/matmul_r16.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_r16.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_r4.c gcc-8-20181012/libgfortran/generated/matmul_r4.c
--- gcc-8.2.0/libgfortran/generated/matmul_r4.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_r4.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmul_r8.c gcc-8-20181012/libgfortran/generated/matmul_r8.c
--- gcc-8.2.0/libgfortran/generated/matmul_r8.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmul_r8.c	2018-08-26 15:02:28.000000000 +0300
@@ -317,8 +317,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -869,8 +874,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1421,8 +1431,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -1987,8 +2002,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -2613,8 +2633,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_c10.c gcc-8-20181012/libgfortran/generated/matmulavx128_c10.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_c10.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_c10.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_c16.c gcc-8-20181012/libgfortran/generated/matmulavx128_c16.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_c16.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_c16.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_c4.c gcc-8-20181012/libgfortran/generated/matmulavx128_c4.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_c4.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_c4.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_c8.c gcc-8-20181012/libgfortran/generated/matmulavx128_c8.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_c8.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_c8.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_i1.c gcc-8-20181012/libgfortran/generated/matmulavx128_i1.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_i1.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_i1.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_i16.c gcc-8-20181012/libgfortran/generated/matmulavx128_i16.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_i16.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_i16.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_i2.c gcc-8-20181012/libgfortran/generated/matmulavx128_i2.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_i2.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_i2.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_i4.c gcc-8-20181012/libgfortran/generated/matmulavx128_i4.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_i4.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_i4.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_i8.c gcc-8-20181012/libgfortran/generated/matmulavx128_i8.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_i8.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_i8.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_r10.c gcc-8-20181012/libgfortran/generated/matmulavx128_r10.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_r10.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_r10.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_r16.c gcc-8-20181012/libgfortran/generated/matmulavx128_r16.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_r16.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_r16.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_r4.c gcc-8-20181012/libgfortran/generated/matmulavx128_r4.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_r4.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_r4.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/generated/matmulavx128_r8.c gcc-8-20181012/libgfortran/generated/matmulavx128_r8.c
--- gcc-8.2.0/libgfortran/generated/matmulavx128_r8.c	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/generated/matmulavx128_r8.c	2018-08-26 15:02:28.000000000 +0300
@@ -282,8 +282,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
@@ -835,8 +840,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgfortran/io/close.c gcc-8-20181012/libgfortran/io/close.c
--- gcc-8.2.0/libgfortran/io/close.c	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libgfortran/io/close.c	2018-10-05 23:16:21.000000000 +0300
@@ -25,6 +25,9 @@
 #include "io.h"
 #include "unix.h"
 #include <limits.h>
+#if !HAVE_UNLINK_OPEN_FILE
+#include <string.h>
+#endif
 
 typedef enum
 { CLOSE_DELETE, CLOSE_KEEP, CLOSE_UNSPECIFIED }
diff -Naur gcc-8.2.0/libgfortran/io/unix.c gcc-8-20181012/libgfortran/io/unix.c
--- gcc-8.2.0/libgfortran/io/unix.c	2018-01-07 13:17:52.000000000 +0300
+++ gcc-8-20181012/libgfortran/io/unix.c	2018-09-18 11:48:28.000000000 +0300
@@ -149,13 +149,21 @@
 {
   int fd;
 
-  if ((mode & R_OK) && (fd = open (path, O_RDONLY)) < 0)
-    return -1;
-  close (fd);
+  if (mode & R_OK)
+    {
+      if ((fd = open (path, O_RDONLY)) < 0)
+	return -1;
+      else
+	close (fd);
+    }
 
-  if ((mode & W_OK) && (fd = open (path, O_WRONLY)) < 0)
-    return -1;
-  close (fd);
+  if (mode & W_OK)
+    {
+      if ((fd = open (path, O_WRONLY)) < 0)
+	return -1;
+      else
+	close (fd);
+    }
 
   if (mode == F_OK)
     {
diff -Naur gcc-8.2.0/libgfortran/m4/matmul_internal.m4 gcc-8-20181012/libgfortran/m4/matmul_internal.m4
--- gcc-8.2.0/libgfortran/m4/matmul_internal.m4	2018-04-06 21:49:21.000000000 +0300
+++ gcc-8-20181012/libgfortran/m4/matmul_internal.m4	2018-08-26 15:02:28.000000000 +0300
@@ -233,8 +233,13 @@
 	return;
 
       /* Adjust size of t1 to what is needed.  */
-      index_type t1_dim;
-      t1_dim = (a_dim1 - (ycount > 1)) * 256 + b_dim1;
+      index_type t1_dim, a_sz;
+      if (aystride == 1)
+        a_sz = rystride;
+      else
+        a_sz = a_dim1;
+
+      t1_dim = a_sz * 256 + b_dim1;
       if (t1_dim > 65536)
 	t1_dim = 65536;
 
diff -Naur gcc-8.2.0/libgo/go/cmd/go/internal/work/buildid.go gcc-8-20181012/libgo/go/cmd/go/internal/work/buildid.go
--- gcc-8.2.0/libgo/go/cmd/go/internal/work/buildid.go	2018-06-01 01:46:52.000000000 +0300
+++ gcc-8-20181012/libgo/go/cmd/go/internal/work/buildid.go	2018-09-14 22:42:27.000000000 +0300
@@ -337,8 +337,12 @@
 	}
 	fmt.Fprintf(&buf, "\n")
 	if cfg.Goos != "solaris" {
-		fmt.Fprintf(&buf, "\t"+`.section .note.GNU-stack,"",@progbits`+"\n")
-		fmt.Fprintf(&buf, "\t"+`.section .note.GNU-split-stack,"",@progbits`+"\n")
+		secType := "@progbits"
+		if cfg.Goarch == "arm" {
+			secType = "%progbits"
+		}
+		fmt.Fprintf(&buf, "\t"+`.section .note.GNU-stack,"",%s`+"\n", secType)
+		fmt.Fprintf(&buf, "\t"+`.section .note.GNU-split-stack,"",%s`+"\n", secType)
 	}
 
 	if cfg.BuildN || cfg.BuildX {
diff -Naur gcc-8.2.0/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc gcc-8-20181012/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
--- gcc-8.2.0/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc	2018-03-19 23:47:29.000000000 +0300
+++ gcc-8-20181012/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc	2018-08-16 13:16:17.000000000 +0300
@@ -235,7 +235,7 @@
         val = FIRST_32_SECOND_64(1168, 1776);
       else if (minor == 11 || (minor == 12 && patch == 1))
         val = FIRST_32_SECOND_64(1168, 2288);
-      else if (minor <= 13)
+      else if (minor <= 14)
         val = FIRST_32_SECOND_64(1168, 2304);
       else
         val = FIRST_32_SECOND_64(1216, 2304);
diff -Naur gcc-8.2.0/libsanitizer/tsan/tsan_platform.h gcc-8-20181012/libsanitizer/tsan/tsan_platform.h
--- gcc-8.2.0/libsanitizer/tsan/tsan_platform.h	2017-10-19 14:23:59.000000000 +0300
+++ gcc-8-20181012/libsanitizer/tsan/tsan_platform.h	2018-08-01 21:17:29.000000000 +0300
@@ -301,6 +301,38 @@
   static const uptr kVdsoBeg       = 0x7800000000000000ull;
 };
 
+/*
+C/C++ on linux/powerpc64 (47-bit VMA)
+0000 0000 1000 - 0100 0000 0000: main binary
+0100 0000 0000 - 0200 0000 0000: -
+0100 0000 0000 - 1000 0000 0000: shadow
+1000 0000 0000 - 1000 0000 0000: -
+1000 0000 0000 - 2000 0000 0000: metainfo (memory blocks and sync objects)
+2000 0000 0000 - 2000 0000 0000: -
+2000 0000 0000 - 2200 0000 0000: traces
+2200 0000 0000 - 7d00 0000 0000: -
+7d00 0000 0000 - 7e00 0000 0000: heap
+7e00 0000 0000 - 7e80 0000 0000: -
+7e80 0000 0000 - 8000 0000 0000: modules and main thread stack
+*/
+struct Mapping47 {
+  static const uptr kMetaShadowBeg = 0x100000000000ull;
+  static const uptr kMetaShadowEnd = 0x200000000000ull;
+  static const uptr kTraceMemBeg   = 0x200000000000ull;
+  static const uptr kTraceMemEnd   = 0x220000000000ull;
+  static const uptr kShadowBeg     = 0x010000000000ull;
+  static const uptr kShadowEnd     = 0x100000000000ull;
+  static const uptr kHeapMemBeg    = 0x7d0000000000ull;
+  static const uptr kHeapMemEnd    = 0x7e0000000000ull;
+  static const uptr kLoAppMemBeg   = 0x000000001000ull;
+  static const uptr kLoAppMemEnd   = 0x010000000000ull;
+  static const uptr kHiAppMemBeg   = 0x7e8000000000ull;
+  static const uptr kHiAppMemEnd   = 0x800000000000ull; // 47 bits
+  static const uptr kAppMemMsk     = 0x7c0000000000ull;
+  static const uptr kAppMemXor     = 0x020000000000ull;
+  static const uptr kVdsoBeg       = 0x7800000000000000ull;
+};
+
 // Indicates the runtime will define the memory regions at runtime.
 #define TSAN_RUNTIME_VMA 1
 #endif
@@ -427,11 +459,13 @@
   DCHECK(0);
   return 0;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return MappingImpl<Mapping44, Type>();
-  else
-    return MappingImpl<Mapping46, Type>();
+  switch (vmaSize) {
+    case 44: return MappingImpl<Mapping44, Type>();
+    case 46: return MappingImpl<Mapping46, Type>();
+    case 47: return MappingImpl<Mapping47, Type>();
+  }
   DCHECK(0);
+  return 0;
 #else
   return MappingImpl<Mapping, Type>();
 #endif
@@ -580,11 +614,13 @@
   DCHECK(0);
   return false;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return IsAppMemImpl<Mapping44>(mem);
-  else
-    return IsAppMemImpl<Mapping46>(mem);
+  switch (vmaSize) {
+    case 44: return IsAppMemImpl<Mapping44>(mem);
+    case 46: return IsAppMemImpl<Mapping46>(mem);
+    case 47: return IsAppMemImpl<Mapping47>(mem);
+  }
   DCHECK(0);
+  return false;
 #else
   return IsAppMemImpl<Mapping>(mem);
 #endif
@@ -607,11 +643,13 @@
   DCHECK(0);
   return false;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return IsShadowMemImpl<Mapping44>(mem);
-  else
-    return IsShadowMemImpl<Mapping46>(mem);
+  switch (vmaSize) {
+    case 44: return IsShadowMemImpl<Mapping44>(mem);
+    case 46: return IsShadowMemImpl<Mapping46>(mem);
+    case 47: return IsShadowMemImpl<Mapping47>(mem);
+  }
   DCHECK(0);
+  return false;
 #else
   return IsShadowMemImpl<Mapping>(mem);
 #endif
@@ -634,11 +672,13 @@
   DCHECK(0);
   return false;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return IsMetaMemImpl<Mapping44>(mem);
-  else
-    return IsMetaMemImpl<Mapping46>(mem);
+  switch (vmaSize) {
+    case 44: return IsMetaMemImpl<Mapping44>(mem);
+    case 46: return IsMetaMemImpl<Mapping46>(mem);
+    case 47: return IsMetaMemImpl<Mapping47>(mem);
+  }
   DCHECK(0);
+  return false;
 #else
   return IsMetaMemImpl<Mapping>(mem);
 #endif
@@ -671,11 +711,13 @@
   DCHECK(0);
   return 0;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return MemToShadowImpl<Mapping44>(x);
-  else
-    return MemToShadowImpl<Mapping46>(x);
+  switch (vmaSize) {
+    case 44: return MemToShadowImpl<Mapping44>(x);
+    case 46: return MemToShadowImpl<Mapping46>(x);
+    case 47: return MemToShadowImpl<Mapping47>(x);
+  }
   DCHECK(0);
+  return 0;
 #else
   return MemToShadowImpl<Mapping>(x);
 #endif
@@ -710,11 +752,13 @@
   DCHECK(0);
   return 0;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return MemToMetaImpl<Mapping44>(x);
-  else
-    return MemToMetaImpl<Mapping46>(x);
+  switch (vmaSize) {
+    case 44: return MemToMetaImpl<Mapping44>(x);
+    case 46: return MemToMetaImpl<Mapping46>(x);
+    case 47: return MemToMetaImpl<Mapping47>(x);
+  }
   DCHECK(0);
+  return 0;
 #else
   return MemToMetaImpl<Mapping>(x);
 #endif
@@ -762,11 +806,13 @@
   DCHECK(0);
   return 0;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return ShadowToMemImpl<Mapping44>(s);
-  else
-    return ShadowToMemImpl<Mapping46>(s);
+  switch (vmaSize) {
+    case 44: return ShadowToMemImpl<Mapping44>(s);
+    case 46: return ShadowToMemImpl<Mapping46>(s);
+    case 47: return ShadowToMemImpl<Mapping47>(s);
+  }
   DCHECK(0);
+  return 0;
 #else
   return ShadowToMemImpl<Mapping>(s);
 #endif
@@ -797,11 +843,13 @@
   DCHECK(0);
   return 0;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return GetThreadTraceImpl<Mapping44>(tid);
-  else
-    return GetThreadTraceImpl<Mapping46>(tid);
+  switch (vmaSize) {
+    case 44: return GetThreadTraceImpl<Mapping44>(tid);
+    case 46: return GetThreadTraceImpl<Mapping46>(tid);
+    case 47: return GetThreadTraceImpl<Mapping47>(tid);
+  }
   DCHECK(0);
+  return 0;
 #else
   return GetThreadTraceImpl<Mapping>(tid);
 #endif
@@ -827,11 +875,13 @@
   DCHECK(0);
   return 0;
 #elif defined(__powerpc64__)
-  if (vmaSize == 44)
-    return GetThreadTraceHeaderImpl<Mapping44>(tid);
-  else
-    return GetThreadTraceHeaderImpl<Mapping46>(tid);
+  switch (vmaSize) {
+    case 44: return GetThreadTraceHeaderImpl<Mapping44>(tid);
+    case 46: return GetThreadTraceHeaderImpl<Mapping46>(tid);
+    case 47: return GetThreadTraceHeaderImpl<Mapping47>(tid);
+  }
   DCHECK(0);
+  return 0;
 #else
   return GetThreadTraceHeaderImpl<Mapping>(tid);
 #endif
diff -Naur gcc-8.2.0/libsanitizer/tsan/tsan_platform_linux.cc gcc-8-20181012/libsanitizer/tsan/tsan_platform_linux.cc
--- gcc-8.2.0/libsanitizer/tsan/tsan_platform_linux.cc	2017-10-19 14:23:59.000000000 +0300
+++ gcc-8-20181012/libsanitizer/tsan/tsan_platform_linux.cc	2018-08-01 21:17:29.000000000 +0300
@@ -214,9 +214,9 @@
     Die();
   }
 #elif defined(__powerpc64__)
-  if (vmaSize != 44 && vmaSize != 46) {
+  if (vmaSize != 44 && vmaSize != 46 && vmaSize != 47) {
     Printf("FATAL: ThreadSanitizer: unsupported VMA range\n");
-    Printf("FATAL: Found %d - Supported 44 and 46\n", vmaSize);
+    Printf("FATAL: Found %d - Supported 44, 46, and 47\n", vmaSize);
     Die();
   }
 #endif
diff -Naur gcc-8.2.0/libstdc++-v3/acinclude.m4 gcc-8-20181012/libstdc++-v3/acinclude.m4
--- gcc-8.2.0/libstdc++-v3/acinclude.m4	2017-11-21 09:22:13.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/acinclude.m4	2018-07-31 12:38:28.000000000 +0300
@@ -3062,7 +3062,7 @@
 dnl
 dnl Defines:
 dnl  _GLIBCXX_USE_INT128
-dnl  _GLIBCXX_USE_FLOAT128
+dnl  ENABLE_FLOAT128
 dnl
 AC_DEFUN([GLIBCXX_ENABLE_INT128_FLOAT128], [
 
@@ -3117,13 +3117,12 @@
 
     AC_MSG_CHECKING([for __float128])
     if AC_TRY_EVAL(ac_compile); then
-      AC_DEFINE(_GLIBCXX_USE_FLOAT128, 1,
-      [Define if __float128 is supported on this host.])
       enable_float128=yes
     else
       enable_float128=no
     fi
     AC_MSG_RESULT($enable_float128)
+    GLIBCXX_CONDITIONAL(ENABLE_FLOAT128, test $enable_float128 = yes)
     rm -f conftest*
 
   AC_LANG_RESTORE
diff -Naur gcc-8.2.0/libstdc++-v3/config.h.in gcc-8-20181012/libstdc++-v3/config.h.in
--- gcc-8.2.0/libstdc++-v3/config.h.in	2018-01-18 22:52:16.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/config.h.in	2018-07-31 12:38:28.000000000 +0300
@@ -918,9 +918,6 @@
 /* Define if fchmodat is available in <sys/stat.h>. */
 #undef _GLIBCXX_USE_FCHMODAT
 
-/* Define if __float128 is supported on this host. */
-#undef _GLIBCXX_USE_FLOAT128
-
 /* Defined if gettimeofday is available. */
 #undef _GLIBCXX_USE_GETTIMEOFDAY
 
diff -Naur gcc-8.2.0/libstdc++-v3/configure gcc-8-20181012/libstdc++-v3/configure
--- gcc-8.2.0/libstdc++-v3/configure	2018-07-04 14:45:51.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/configure	2018-08-13 22:15:40.000000000 +0300
@@ -729,6 +729,8 @@
 CSTDIO_H
 SECTION_FLAGS
 WERROR
+ENABLE_FLOAT128_FALSE
+ENABLE_FLOAT128_TRUE
 thread_header
 glibcxx_PCHFLAGS
 GLIBCXX_BUILD_PCH_FALSE
@@ -11606,7 +11608,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11609 "configure"
+#line 11611 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11712,7 +11714,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11715 "configure"
+#line 11717 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15398,7 +15400,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15401 "configure"
+#line 15403 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15433,7 +15435,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15436 "configure"
+#line 15438 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15468,7 +15470,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15471 "configure"
+#line 15473 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15504,7 +15506,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15507 "configure"
+#line 15509 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15585,7 +15587,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15588 "configure"
+#line 15590 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15627,7 +15629,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15630 "configure"
+#line 15632 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15661,7 +15663,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15664 "configure"
+#line 15666 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15683,15 +15685,13 @@
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-
-$as_echo "#define _GLIBCXX_USE_FLOAT128 1" >>confdefs.h
-
       enable_float128=yes
     else
       enable_float128=no
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_float128" >&5
 $as_echo "$enable_float128" >&6; }
+
     rm -f conftest*
 
   ac_ext=c
@@ -81261,6 +81261,15 @@
 fi
 
 
+    if test $enable_float128 = yes; then
+  ENABLE_FLOAT128_TRUE=
+  ENABLE_FLOAT128_FALSE='#'
+else
+  ENABLE_FLOAT128_TRUE='#'
+  ENABLE_FLOAT128_FALSE=
+fi
+
+
     if test $enable_libstdcxx_allocator_flag = new; then
   ENABLE_ALLOCATOR_NEW_TRUE=
   ENABLE_ALLOCATOR_NEW_FALSE='#'
@@ -81804,6 +81813,10 @@
   as_fn_error "conditional \"GLIBCXX_BUILD_PCH\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${ENABLE_FLOAT128_TRUE}" && test -z "${ENABLE_FLOAT128_FALSE}"; then
+  as_fn_error "conditional \"ENABLE_FLOAT128\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${ENABLE_ALLOCATOR_NEW_TRUE}" && test -z "${ENABLE_ALLOCATOR_NEW_FALSE}"; then
   as_fn_error "conditional \"ENABLE_ALLOCATOR_NEW\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/c++config gcc-8-20181012/libstdc++-v3/include/bits/c++config
--- gcc-8.2.0/libstdc++-v3/include/bits/c++config	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/c++config	2018-07-31 12:38:28.000000000 +0300
@@ -609,4 +609,9 @@
 # endif
 #endif
 
+/* Define if __float128 is supported on this host. */
+#if defined(__FLOAT128__) || defined(__SIZEOF_FLOAT128__)
+#define _GLIBCXX_USE_FLOAT128
+#endif
+
 // End of prewritten config; the settings discovered at configure time follow.
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/fs_dir.h gcc-8-20181012/libstdc++-v3/include/bits/fs_dir.h
--- gcc-8.2.0/libstdc++-v3/include/bits/fs_dir.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/fs_dir.h	2018-08-08 18:33:32.000000000 +0300
@@ -313,7 +313,10 @@
     _M_file_type(error_code& __ec) const noexcept
     {
       if (_M_type != file_type::none && _M_type != file_type::symlink)
-	return _M_type;
+	{
+	  __ec.clear();
+	  return _M_type;
+	}
       return status(__ec).type();
     }
 
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/shared_ptr.h gcc-8-20181012/libstdc++-v3/include/bits/shared_ptr.h
--- gcc-8.2.0/libstdc++-v3/include/bits/shared_ptr.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/shared_ptr.h	2018-09-11 14:51:10.000000000 +0300
@@ -718,7 +718,7 @@
     inline shared_ptr<_Tp>
     make_shared(_Args&&... __args)
     {
-      typedef typename std::remove_const<_Tp>::type _Tp_nc;
+      typedef typename std::remove_cv<_Tp>::type _Tp_nc;
       return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
 				       std::forward<_Args>(__args)...);
     }
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/shared_ptr_base.h gcc-8-20181012/libstdc++-v3/include/bits/shared_ptr_base.h
--- gcc-8.2.0/libstdc++-v3/include/bits/shared_ptr_base.h	2018-06-05 01:34:39.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/shared_ptr_base.h	2018-07-31 12:38:41.000000000 +0300
@@ -508,7 +508,7 @@
       friend class _Sp_counted_ptr_inplace;
 
     static const type_info&
-    _S_ti() noexcept
+    _S_ti() noexcept _GLIBCXX_VISIBILITY(default)
     {
       alignas(type_info) static constexpr _Sp_make_shared_tag __tag;
       return reinterpret_cast<const type_info&>(__tag);
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/stl_iterator.h gcc-8-20181012/libstdc++-v3/include/bits/stl_iterator.h
--- gcc-8.2.0/libstdc++-v3/include/bits/stl_iterator.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/stl_iterator.h	2018-07-31 12:38:37.000000000 +0300
@@ -122,6 +122,7 @@
       */
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // 235 No specification of default ctor for reverse_iterator
+      // 1012. reverse_iterator default ctor should value initialize
       _GLIBCXX17_CONSTEXPR
       reverse_iterator() : current() { }
 
@@ -176,9 +177,11 @@
        *
        *  This requires that @c --current is dereferenceable.
       */
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2188. Reverse iterator does not fully support targets that overload &
       _GLIBCXX17_CONSTEXPR pointer
       operator->() const
-      { return &(operator*()); }
+      { return std::__addressof(operator*()); }
 
       /**
        *  @return  @c *this
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/stl_map.h gcc-8-20181012/libstdc++-v3/include/bits/stl_map.h
--- gcc-8.2.0/libstdc++-v3/include/bits/stl_map.h	2018-03-21 00:45:14.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/stl_map.h	2018-10-12 15:28:48.000000000 +0300
@@ -808,12 +808,11 @@
       insert(value_type&& __x)
       { return _M_t._M_insert_unique(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	std::pair<iterator, bool>
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair>::value,
+		      pair<iterator, bool>>
 	insert(_Pair&& __x)
-	{ return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }
+	{ return _M_t._M_emplace_unique(std::forward<_Pair>(__x)); }
 #endif
       // @}
 
@@ -869,13 +868,13 @@
       insert(const_iterator __position, value_type&& __x)
       { return _M_t._M_insert_unique_(__position, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 	insert(const_iterator __position, _Pair&& __x)
-	{ return _M_t._M_insert_unique_(__position,
-					std::forward<_Pair>(__x)); }
+	{
+	  return _M_t._M_emplace_hint_unique(__position,
+					     std::forward<_Pair>(__x));
+	}
 #endif
       // @}
 
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/stl_multimap.h gcc-8-20181012/libstdc++-v3/include/bits/stl_multimap.h
--- gcc-8.2.0/libstdc++-v3/include/bits/stl_multimap.h	2018-03-21 00:45:14.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/stl_multimap.h	2018-10-12 15:28:48.000000000 +0300
@@ -544,12 +544,10 @@
       insert(value_type&& __x)
       { return _M_t._M_insert_equal(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair>::value, iterator>
 	insert(_Pair&& __x)
-	{ return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }
+	{ return _M_t._M_emplace_equal(std::forward<_Pair>(__x)); }
 #endif
       // @}
 
@@ -589,13 +587,13 @@
       insert(const_iterator __position, value_type&& __x)
       { return _M_t._M_insert_equal_(__position, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __position, _Pair&& __x)
-	{ return _M_t._M_insert_equal_(__position,
-				       std::forward<_Pair>(__x)); }
+	{
+	  return _M_t._M_emplace_hint_equal(__position,
+					    std::forward<_Pair>(__x));
+	}
 #endif
       // @}
 
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/stl_pair.h gcc-8-20181012/libstdc++-v3/include/bits/stl_pair.h
--- gcc-8.2.0/libstdc++-v3/include/bits/stl_pair.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/stl_pair.h	2018-10-12 15:28:54.000000000 +0300
@@ -185,8 +185,18 @@
   struct __nonesuch_no_braces : std::__nonesuch {
     explicit __nonesuch_no_braces(const __nonesuch&) = delete;
   };
+#endif // C++11
 
-#endif
+  class __pair_base
+  {
+#if __cplusplus >= 201103L
+    template<typename _T1, typename _T2> friend struct pair;
+    __pair_base() = default;
+    ~__pair_base() = default;
+    __pair_base(const __pair_base&) = default;
+    __pair_base& operator=(const __pair_base&) = delete;
+#endif // C++11
+  };
 
  /**
    *  @brief Struct holding two objects of arbitrary type.
@@ -196,6 +206,7 @@
    */
   template<typename _T1, typename _T2>
     struct pair
+    : private __pair_base
     {
       typedef _T1 first_type;    /// @c first_type is the first bound type
       typedef _T2 second_type;   /// @c second_type is the second bound type
@@ -376,17 +387,11 @@
 
       pair&
       operator=(typename conditional<
-		__not_<__and_<is_copy_assignable<_T1>,
-		              is_copy_assignable<_T2>>>::value,
-		const pair&, const __nonesuch_no_braces&>::type __p) = delete;
-
-      pair&
-      operator=(typename conditional<
 		__and_<is_move_assignable<_T1>,
 		       is_move_assignable<_T2>>::value,
 		pair&&, __nonesuch_no_braces&&>::type __p)
       noexcept(__and_<is_nothrow_move_assignable<_T1>,
-	              is_nothrow_move_assignable<_T2>>::value)
+		      is_nothrow_move_assignable<_T2>>::value)
       {
 	first = std::forward<first_type>(__p.first);
 	second = std::forward<second_type>(__p.second);
diff -Naur gcc-8.2.0/libstdc++-v3/include/bits/unordered_map.h gcc-8-20181012/libstdc++-v3/include/bits/unordered_map.h
--- gcc-8.2.0/libstdc++-v3/include/bits/unordered_map.h	2018-03-21 00:45:14.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/bits/unordered_map.h	2018-10-12 15:28:48.000000000 +0300
@@ -585,12 +585,11 @@
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	std::pair<iterator, bool>
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value,
+		      pair<iterator, bool>>
 	insert(_Pair&& __x)
-        { return _M_h.insert(std::forward<_Pair>(__x)); }
+        { return _M_h.emplace(std::forward<_Pair>(__x)); }
       //@}
 
       //@{
@@ -625,12 +624,10 @@
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
-	{ return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
+	{ return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
       //@}
 
       /**
@@ -1560,12 +1557,10 @@
       insert(value_type&& __x)
       { return _M_h.insert(std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(_Pair&& __x)
-        { return _M_h.insert(std::forward<_Pair>(__x)); }
+        { return _M_h.emplace(std::forward<_Pair>(__x)); }
       //@}
 
       //@{
@@ -1598,12 +1593,10 @@
       insert(const_iterator __hint, value_type&& __x)
       { return _M_h.insert(__hint, std::move(__x)); }
 
-      template<typename _Pair, typename = typename
-	       std::enable_if<std::is_constructible<value_type,
-						    _Pair&&>::value>::type>
-	iterator
+      template<typename _Pair>
+	__enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 	insert(const_iterator __hint, _Pair&& __x)
-        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
+        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
       //@}
 
       /**
diff -Naur gcc-8.2.0/libstdc++-v3/include/experimental/memory_resource gcc-8-20181012/libstdc++-v3/include/experimental/memory_resource
--- gcc-8.2.0/libstdc++-v3/include/experimental/memory_resource	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/experimental/memory_resource	2018-10-12 15:28:30.000000000 +0300
@@ -33,7 +33,6 @@
 #include <new>
 #include <atomic>
 #include <cstddef>
-#include <bits/alloc_traits.h>
 #include <experimental/bits/lfts_config.h>
 
 namespace std {
@@ -258,6 +257,22 @@
   template <typename _Alloc>
     class __resource_adaptor_imp : public memory_resource
     {
+      static_assert(is_same<char,
+	  typename allocator_traits<_Alloc>::value_type>::value,
+	  "Allocator's value_type is char");
+      static_assert(is_same<char*,
+	  typename allocator_traits<_Alloc>::pointer>::value,
+	  "Allocator's pointer type is value_type*");
+      static_assert(is_same<const char*,
+	  typename allocator_traits<_Alloc>::const_pointer>::value,
+	  "Allocator's const_pointer type is value_type const*");
+      static_assert(is_same<void*,
+	  typename allocator_traits<_Alloc>::void_pointer>::value,
+	  "Allocator's void_pointer type is void*");
+      static_assert(is_same<const void*,
+	  typename allocator_traits<_Alloc>::const_void_pointer>::value,
+	  "Allocator's const_void_pointer type is void const*");
+
     public:
       using allocator_type = _Alloc;
 
@@ -276,7 +291,7 @@
       __resource_adaptor_imp&
       operator=(const __resource_adaptor_imp&) = default;
 
-      allocator_type get_allocator() const { return _M_alloc; }
+      allocator_type get_allocator() const noexcept { return _M_alloc; }
 
     protected:
       virtual void*
@@ -311,13 +326,13 @@
     private:
       // Calculate Aligned Size
       // Returns a size that is larger than or equal to __size and divisible
-      // by __alignment, where __alignment is required to be the power of 2.
+      // by __alignment, where __alignment is required to be a power of 2.
       static size_t
       _S_aligned_size(size_t __size, size_t __alignment)
       { return ((__size - 1)|(__alignment - 1)) + 1; }
 
       // Determine whether alignment meets one of those preconditions:
-      // 1. Equals to Zero
+      // 1. Equal to Zero
       // 2. Is power of two
       static bool
       _S_supported (size_t __x)
@@ -327,47 +342,50 @@
     };
 
   // Global memory resources
-  inline std::atomic<memory_resource*>&
-  __get_default_resource()
-  {
-    static atomic<memory_resource*> _S_default_resource(new_delete_resource());
-    return _S_default_resource;
-  }
 
   inline memory_resource*
   new_delete_resource() noexcept
   {
-    static resource_adaptor<std::allocator<char>> __r;
-    return static_cast<memory_resource*>(&__r);
+    using type = resource_adaptor<std::allocator<char>>;
+    alignas(type) static unsigned char __buf[sizeof(type)];
+    static type* __r = new(__buf) type;
+    return __r;
   }
 
-  template <typename _Alloc>
-    class __null_memory_resource : private memory_resource
+  inline memory_resource*
+  null_memory_resource() noexcept
+  {
+    class type final : public memory_resource
     {
-    protected:
       void*
-      do_allocate(size_t, size_t)
+      do_allocate(size_t, size_t) override
       { std::__throw_bad_alloc(); }
 
       void
-      do_deallocate(void*, size_t, size_t) noexcept
+      do_deallocate(void*, size_t, size_t) noexcept override
       { }
 
       bool
-      do_is_equal(const memory_resource& __other) const noexcept
+      do_is_equal(const memory_resource& __other) const noexcept override
       { return this == &__other; }
-
-      friend memory_resource* null_memory_resource() noexcept;
     };
 
-  inline memory_resource*
-  null_memory_resource() noexcept
-  {
-    static __null_memory_resource<void> __r;
-    return static_cast<memory_resource*>(&__r);
+    alignas(type) static unsigned char __buf[sizeof(type)];
+    static type* __r = new(__buf) type;
+    return __r;
   }
 
   // The default memory resource
+
+  inline std::atomic<memory_resource*>&
+  __get_default_resource()
+  {
+    using type = atomic<memory_resource*>;
+    alignas(type) static unsigned char __buf[sizeof(type)];
+    static type* __r = new(__buf) type(new_delete_resource());
+    return *__r;
+  }
+
   inline memory_resource*
   get_default_resource() noexcept
   { return __get_default_resource().load(); }
diff -Naur gcc-8.2.0/libstdc++-v3/include/experimental/regex gcc-8-20181012/libstdc++-v3/include/experimental/regex
--- gcc-8.2.0/libstdc++-v3/include/experimental/regex	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/experimental/regex	2018-10-12 15:28:36.000000000 +0300
@@ -44,10 +44,9 @@
 {
 inline namespace fundamentals_v2
 {
+#if _GLIBCXX_USE_CXX11_ABI
 namespace pmr
 {
-_GLIBCXX_BEGIN_NAMESPACE_CXX11
-
   template<typename _BidirectionalIterator>
     using match_results
       = std::match_results<_BidirectionalIterator, polymorphic_allocator<
@@ -58,9 +57,8 @@
   typedef match_results<string::const_iterator> smatch;
   typedef match_results<wstring::const_iterator> wsmatch;
 
-_GLIBCXX_END_NAMESPACE_CXX11
 } // namespace pmr
-
+#endif
 } // namespace fundamentals_v2
 } // namespace experimental
 _GLIBCXX_END_NAMESPACE_VERSION
diff -Naur gcc-8.2.0/libstdc++-v3/include/experimental/string gcc-8-20181012/libstdc++-v3/include/experimental/string
--- gcc-8.2.0/libstdc++-v3/include/experimental/string	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/experimental/string	2018-10-12 15:28:36.000000000 +0300
@@ -62,9 +62,9 @@
 		   __cont.end());
     }
 
-  namespace pmr {
-  _GLIBCXX_BEGIN_NAMESPACE_CXX11
-
+#if _GLIBCXX_USE_CXX11_ABI
+  namespace pmr
+  {
     // basic_string using polymorphic allocator in namespace pmr
     template<typename _CharT, typename _Traits = char_traits<_CharT>>
       using basic_string =
@@ -77,8 +77,8 @@
     typedef basic_string<char32_t> u32string;
     typedef basic_string<wchar_t> wstring;
 
-    _GLIBCXX_END_NAMESPACE_CXX11
   } // namespace pmr
+#endif
 } // namespace fundamentals_v2
 } // namespace experimental
 
diff -Naur gcc-8.2.0/libstdc++-v3/include/ext/pointer.h gcc-8-20181012/libstdc++-v3/include/ext/pointer.h
--- gcc-8.2.0/libstdc++-v3/include/ext/pointer.h	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/ext/pointer.h	2018-10-12 15:28:42.000000000 +0300
@@ -437,6 +437,10 @@
       _CXX_POINTER_ARITH_OPERATOR_SET(unsigned int);
       _CXX_POINTER_ARITH_OPERATOR_SET(long);
       _CXX_POINTER_ARITH_OPERATOR_SET(unsigned long);
+#ifdef _GLIBCXX_USE_LONG_LONG
+      _CXX_POINTER_ARITH_OPERATOR_SET(long long);
+      _CXX_POINTER_ARITH_OPERATOR_SET(unsigned long long);
+#endif
 
       // Mathematical Manipulators
       inline _Pointer_adapter& 
diff -Naur gcc-8.2.0/libstdc++-v3/include/Makefile.am gcc-8-20181012/libstdc++-v3/include/Makefile.am
--- gcc-8.2.0/libstdc++-v3/include/Makefile.am	2018-02-15 23:56:41.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/Makefile.am	2018-07-31 12:38:28.000000000 +0300
@@ -1230,6 +1230,14 @@
 	echo 0 > stamp-allocator-new
 endif
 
+if ENABLE_FLOAT128
+stamp-float128:
+	echo 'define _GLIBCXX_USE_FLOAT128 1' > stamp-float128
+else
+stamp-float128:
+	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
+endif
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
@@ -1241,7 +1249,8 @@
 			      stamp-extern-template \
 			      stamp-dual-abi \
 			      stamp-cxx11-abi \
-			      stamp-allocator-new
+			      stamp-allocator-new \
+			      stamp-float128
 	@date=`cat ${toplevel_srcdir}/gcc/DATESTAMP` ;\
 	release=`sed 's/^\([0-9]*\).*$$/\1/' ${toplevel_srcdir}/gcc/BASE-VER` ;\
 	ns_version=`cat stamp-namespace-version` ;\
@@ -1250,6 +1259,7 @@
 	dualabi=`cat stamp-dual-abi` ;\
 	cxx11abi=`cat stamp-cxx11-abi` ;\
 	allocatornew=`cat stamp-allocator-new` ;\
+	float128=`cat stamp-float128` ;\
 	ldbl_compat='s,g,g,' ;\
 	grep "^[	 ]*#[	 ]*define[	 ][	 ]*_GLIBCXX_LONG_DOUBLE_COMPAT[	 ][	 ]*1[	 ]*$$" \
 	${CONFIG_HEADER} > /dev/null 2>&1 \
@@ -1262,6 +1272,7 @@
 	-e "s,define _GLIBCXX_USE_DUAL_ABI, define _GLIBCXX_USE_DUAL_ABI $$dualabi," \
 	-e "s,define _GLIBCXX_USE_CXX11_ABI, define _GLIBCXX_USE_CXX11_ABI $$cxx11abi," \
 	-e "s,define _GLIBCXX_USE_ALLOCATOR_NEW, define _GLIBCXX_USE_ALLOCATOR_NEW $$allocatornew," \
+	-e "s,define _GLIBCXX_USE_FLOAT128,$$float128," \
 	-e "$$ldbl_compat" \
 	    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\
 	sed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \
diff -Naur gcc-8.2.0/libstdc++-v3/include/Makefile.in gcc-8-20181012/libstdc++-v3/include/Makefile.in
--- gcc-8.2.0/libstdc++-v3/include/Makefile.in	2018-02-15 23:56:41.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/Makefile.in	2018-07-31 12:38:28.000000000 +0300
@@ -1662,6 +1662,11 @@
 @ENABLE_ALLOCATOR_NEW_FALSE@stamp-allocator-new:
 @ENABLE_ALLOCATOR_NEW_FALSE@	echo 0 > stamp-allocator-new
 
+@ENABLE_FLOAT128_TRUE@stamp-float128:
+@ENABLE_FLOAT128_TRUE@	echo 'define _GLIBCXX_USE_FLOAT128 1' > stamp-float128
+@ENABLE_FLOAT128_FALSE@stamp-float128:
+@ENABLE_FLOAT128_FALSE@	echo 'undef _GLIBCXX_USE_FLOAT128' > stamp-float128
+
 # NB: The non-empty default ldbl_compat works around an AIX sed
 # oddity, see libstdc++/31957 for details.
 ${host_builddir}/c++config.h: ${CONFIG_HEADER} \
@@ -1673,7 +1678,8 @@
 			      stamp-extern-template \
 			      stamp-dual-abi \
 			      stamp-cxx11-abi \
-			      stamp-allocator-new
+			      stamp-allocator-new \
+			      stamp-float128
 	@date=`cat ${toplevel_srcdir}/gcc/DATESTAMP` ;\
 	release=`sed 's/^\([0-9]*\).*$$/\1/' ${toplevel_srcdir}/gcc/BASE-VER` ;\
 	ns_version=`cat stamp-namespace-version` ;\
@@ -1682,6 +1688,7 @@
 	dualabi=`cat stamp-dual-abi` ;\
 	cxx11abi=`cat stamp-cxx11-abi` ;\
 	allocatornew=`cat stamp-allocator-new` ;\
+	float128=`cat stamp-float128` ;\
 	ldbl_compat='s,g,g,' ;\
 	grep "^[	 ]*#[	 ]*define[	 ][	 ]*_GLIBCXX_LONG_DOUBLE_COMPAT[	 ][	 ]*1[	 ]*$$" \
 	${CONFIG_HEADER} > /dev/null 2>&1 \
@@ -1694,6 +1701,7 @@
 	-e "s,define _GLIBCXX_USE_DUAL_ABI, define _GLIBCXX_USE_DUAL_ABI $$dualabi," \
 	-e "s,define _GLIBCXX_USE_CXX11_ABI, define _GLIBCXX_USE_CXX11_ABI $$cxx11abi," \
 	-e "s,define _GLIBCXX_USE_ALLOCATOR_NEW, define _GLIBCXX_USE_ALLOCATOR_NEW $$allocatornew," \
+	-e "s,define _GLIBCXX_USE_FLOAT128,$$float128," \
 	-e "$$ldbl_compat" \
 	    < ${glibcxx_srcdir}/include/bits/c++config > $@ ;\
 	sed -e 's/HAVE_/_GLIBCXX_HAVE_/g' \
diff -Naur gcc-8.2.0/libstdc++-v3/include/std/functional gcc-8-20181012/libstdc++-v3/include/std/functional
--- gcc-8.2.0/libstdc++-v3/include/std/functional	2018-01-04 13:21:29.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/std/functional	2018-10-08 15:54:41.000000000 +0300
@@ -864,7 +864,8 @@
       template<typename... _Args>					\
 	decltype(_S_not<__inv_res_t<_Fn _QUALS, _Args...>>())		\
 	operator()(_Args&&... __args) _QUALS				\
-	noexcept(noexcept(_S_not<__inv_res_t<_Fn _QUALS, _Args...>>()))	\
+	noexcept(__is_nothrow_invocable<_Fn _QUALS, _Args...>::value	\
+	    && noexcept(_S_not<__inv_res_t<_Fn _QUALS, _Args...>>()))	\
 	{								\
 	  return !std::__invoke(std::forward< _Fn _QUALS >(_M_fn),	\
 				std::forward<_Args>(__args)...);	\
diff -Naur gcc-8.2.0/libstdc++-v3/include/std/thread gcc-8-20181012/libstdc++-v3/include/std/thread
--- gcc-8.2.0/libstdc++-v3/include/std/thread	2018-02-24 02:23:43.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/std/thread	2018-08-08 00:38:59.000000000 +0300
@@ -102,21 +102,26 @@
   private:
     id				_M_id;
 
-  public:
-    thread() noexcept = default;
     // _GLIBCXX_RESOLVE_LIB_DEFECTS
     // 2097.  packaged_task constructors should be constrained
-    thread(thread&) = delete;
-    thread(const thread&) = delete;
-    thread(const thread&&) = delete;
+    template<typename _Tp>
+      using __not_same = __not_<is_same<
+	typename remove_cv<typename remove_reference<_Tp>::type>::type,
+	thread>>;
 
-    thread(thread&& __t) noexcept
-    { swap(__t); }
+  public:
+    thread() noexcept = default;
 
-    template<typename _Callable, typename... _Args>
+    template<typename _Callable, typename... _Args,
+	     typename = _Require<__not_same<_Callable>>>
       explicit
       thread(_Callable&& __f, _Args&&... __args)
       {
+	static_assert( __is_invocable<typename decay<_Callable>::type,
+				      typename decay<_Args>::type...>::value,
+	  "std::thread arguments must be invocable after conversion to rvalues"
+	  );
+
 #ifdef GTHR_ACTIVE_PROXY
 	// Create a reference to pthread_create, not just the gthr weak symbol.
 	auto __depend = reinterpret_cast<void(*)()>(&pthread_create);
@@ -135,6 +140,11 @@
 	std::terminate();
     }
 
+    thread(const thread&) = delete;
+
+    thread(thread&& __t) noexcept
+    { swap(__t); }
+
     thread& operator=(const thread&) = delete;
 
     thread& operator=(thread&& __t) noexcept
diff -Naur gcc-8.2.0/libstdc++-v3/include/std/type_traits gcc-8-20181012/libstdc++-v3/include/std/type_traits
--- gcc-8.2.0/libstdc++-v3/include/std/type_traits	2018-07-04 14:44:11.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/std/type_traits	2018-10-12 15:28:48.000000000 +0300
@@ -2313,7 +2313,7 @@
     : public __invoke_result<_Functor, _ArgTypes...>
     { };
 
-#if __cplusplus > 201103L
+#if __cplusplus >= 201402L
   /// Alias template for aligned_storage
   template<size_t _Len, size_t _Align =
 	    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
@@ -2345,11 +2345,16 @@
   /// Alias template for result_of
   template<typename _Tp>
     using result_of_t = typename result_of<_Tp>::type;
-#endif
+#endif // C++14
 
+  // __enable_if_t (std::enable_if_t for C++11)
+  template<bool _Cond, typename _Tp = void>
+    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
+
+  // __void_t (std::void_t for C++11)
   template<typename...> using __void_t = void;
 
-#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
+#if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++11
 #define __cpp_lib_void_t 201411
   /// A metafunction that always yields void, used for detecting valid types.
   template<typename...> using void_t = void;
diff -Naur gcc-8.2.0/libstdc++-v3/include/std/variant gcc-8-20181012/libstdc++-v3/include/std/variant
--- gcc-8.2.0/libstdc++-v3/include/std/variant	2018-07-04 14:46:39.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/include/std/variant	2018-08-08 00:38:50.000000000 +0300
@@ -506,6 +506,20 @@
 	  }
       }
 
+      void _M_destructive_move(_Move_ctor_base&& __rhs)
+      {
+	this->~_Move_ctor_base();
+	__try
+	  {
+	    ::new (this) _Move_ctor_base(std::move(__rhs));
+	  }
+	__catch (...)
+	  {
+	    this->_M_index = variant_npos;
+	    __throw_exception_again;
+	  }
+      }
+
       _Move_ctor_base(const _Move_ctor_base&) = default;
       _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
       _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
@@ -516,6 +530,12 @@
     {
       using _Base = _Copy_ctor_alias<_Types...>;
       using _Base::_Base;
+
+      void _M_destructive_move(_Move_ctor_base&& __rhs)
+      {
+	this->~_Move_ctor_base();
+	::new (this) _Move_ctor_base(std::move(__rhs));
+      }
     };
 
   template<typename... _Types>
@@ -538,22 +558,14 @@
 	      {
 		static constexpr void (*_S_vtable[])(void*, void*) =
 		  { &__erased_assign<_Types&, const _Types&>... };
-		_S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());
+		_S_vtable[__rhs._M_index](this->_M_storage(),
+					  __rhs._M_storage());
 	      }
 	  }
 	else
 	  {
 	    _Copy_assign_base __tmp(__rhs);
-	    this->~_Copy_assign_base();
-	    __try
-	      {
-		::new (this) _Copy_assign_base(std::move(__tmp));
-	      }
-	    __catch (...)
-	      {
-		this->_M_index = variant_npos;
-		__throw_exception_again;
-	      }
+	    this->_M_destructive_move(std::move(__tmp));
 	  }
 	__glibcxx_assert(this->_M_index == __rhs._M_index);
 	return *this;
@@ -582,20 +594,6 @@
       using _Base = _Copy_assign_alias<_Types...>;
       using _Base::_Base;
 
-      void _M_destructive_move(_Move_assign_base&& __rhs)
-      {
-	this->~_Move_assign_base();
-	__try
-	  {
-	    ::new (this) _Move_assign_base(std::move(__rhs));
-	  }
-	__catch (...)
-	  {
-	    this->_M_index = variant_npos;
-	    __throw_exception_again;
-	  }
-      }
-
       _Move_assign_base&
       operator=(_Move_assign_base&& __rhs)
 	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
@@ -613,16 +611,7 @@
 	else
 	  {
 	    _Move_assign_base __tmp(std::move(__rhs));
-	    this->~_Move_assign_base();
-	    __try
-	      {
-		::new (this) _Move_assign_base(std::move(__tmp));
-	      }
-	    __catch (...)
-	      {
-		this->_M_index = variant_npos;
-		__throw_exception_again;
-	      }
+	    this->_M_destructive_move(std::move(__tmp));
 	  }
 	__glibcxx_assert(this->_M_index == __rhs._M_index);
 	return *this;
diff -Naur gcc-8.2.0/libstdc++-v3/libsupc++/new_opa.cc gcc-8-20181012/libstdc++-v3/libsupc++/new_opa.cc
--- gcc-8.2.0/libstdc++-v3/libsupc++/new_opa.cc	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/libsupc++/new_opa.cc	2018-08-08 18:33:36.000000000 +0300
@@ -25,20 +25,36 @@
 
 #include <bits/c++config.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <bits/exception_defines.h>
 #include "new"
 
+#if !_GLIBCXX_HAVE_ALIGNED_ALLOC && !_GLIBCXX_HAVE__ALIGNED_MALLOC \
+  && !_GLIBCXX_HAVE_POSIX_MEMALIGN && _GLIBCXX_HAVE_MEMALIGN
+# if _GLIBCXX_HOSTED && __has_include(<malloc.h>)
+// Some C libraries declare memalign in <malloc.h>
+#  include <malloc.h>
+# else
+extern "C" void *memalign(std::size_t boundary, std::size_t size);
+# endif
+#endif
+
 using std::new_handler;
 using std::bad_alloc;
 
-#if !_GLIBCXX_HAVE_ALIGNED_ALLOC
-#if _GLIBCXX_HAVE__ALIGNED_MALLOC
-#define aligned_alloc(al,sz) _aligned_malloc(sz,al)
+namespace __gnu_cxx {
+#if _GLIBCXX_HAVE_ALIGNED_ALLOC
+using ::aligned_alloc;
+#elif _GLIBCXX_HAVE__ALIGNED_MALLOC
+static inline void*
+aligned_alloc (std::size_t al, std::size_t sz)
+{ return _aligned_malloc(sz, al); }
 #elif _GLIBCXX_HAVE_POSIX_MEMALIGN
 static inline void*
 aligned_alloc (std::size_t al, std::size_t sz)
 {
   void *ptr;
+  // posix_memalign has additional requirement, not present on aligned_alloc:
   // The value of alignment shall be a power of two multiple of sizeof(void *).
   if (al < sizeof(void*))
     al = sizeof(void*);
@@ -48,25 +64,23 @@
   return nullptr;
 }
 #elif _GLIBCXX_HAVE_MEMALIGN
-#if _GLIBCXX_HOSTED
-#include <malloc.h>
-#else
-extern "C" void *memalign(std::size_t boundary, std::size_t size);
+static inline void*
+aligned_alloc (std::size_t al, std::size_t sz)
+{
+#ifdef __sun
+  // Solaris 10 memalign requires that alignment is greater than or equal to
+  // the size of a word.
+  if (al < sizeof(int))
+    al = sizeof(int);
 #endif
-#define aligned_alloc memalign
-#else
-#include <stdint.h>
+  return memalign (al, sz);
+}
+#else // !HAVE__ALIGNED_MALLOC && !HAVE_POSIX_MEMALIGN && !HAVE_MEMALIGN
 // The C library doesn't provide any aligned allocation functions, define one.
 // This is a modified version of code from gcc/config/i386/gmm_malloc.h
 static inline void*
 aligned_alloc (std::size_t al, std::size_t sz)
 {
-  // Alignment must be a power of two.
-  if (al & (al - 1))
-    return nullptr;
-  else if (!sz)
-    return nullptr;
-
   // We need extra bytes to store the original value returned by malloc.
   if (al < sizeof(void*))
     al = sizeof(void*);
@@ -82,7 +96,7 @@
   return aligned_ptr;
 }
 #endif
-#endif
+} // namespace __gnu_cxx
 
 _GLIBCXX_WEAK_DEFINITION void *
 operator new (std::size_t sz, std::align_val_t al)
@@ -90,16 +104,28 @@
   void *p;
   std::size_t align = (std::size_t)al;
 
+  /* Alignment must be a power of two.  */
+  /* XXX This should be checked by the compiler (PR 86878).  */
+  if (__builtin_expect (align & (align - 1), false))
+    _GLIBCXX_THROW_OR_ABORT(bad_alloc());
+
   /* malloc (0) is unpredictable; avoid it.  */
-  if (sz == 0)
+  if (__builtin_expect (sz == 0, false))
     sz = 1;
 
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
+# ifdef _AIX
+  /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement
+   * that alignment is a multiple of sizeof(void*).  */
+  if (align < sizeof(void*))
+    align = sizeof(void*);
+# endif
   /* C11: the value of size shall be an integral multiple of alignment.  */
   if (std::size_t rem = sz & (align - 1))
     sz += align - rem;
 #endif
 
+  using __gnu_cxx::aligned_alloc;
   while (__builtin_expect ((p = aligned_alloc (align, sz)) == 0, false))
     {
       new_handler handler = std::get_new_handler ();
diff -Naur gcc-8.2.0/libstdc++-v3/python/libstdcxx/v6/printers.py gcc-8-20181012/libstdc++-v3/python/libstdcxx/v6/printers.py
--- gcc-8.2.0/libstdc++-v3/python/libstdcxx/v6/printers.py	2018-06-26 00:06:56.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/python/libstdcxx/v6/printers.py	2018-10-12 15:28:54.000000000 +0300
@@ -1229,6 +1229,39 @@
         return self._iterator(self.val['_M_cmpts'])
 
 
+class StdPairPrinter:
+    "Print a std::pair object, with 'first' and 'second' as children"
+
+    def __init__(self, typename, val):
+        self.val = val
+
+    class _iter(Iterator):
+        "An iterator for std::pair types. Returns 'first' then 'second'."
+
+        def __init__(self, val):
+            self.val = val
+            self.which = 'first'
+
+        def __iter__(self):
+            return self
+
+        def __next__(self):
+            if self.which is None:
+                raise StopIteration
+            which = self.which
+            if which == 'first':
+                self.which = 'second'
+            else:
+                self.which = None
+            return (which, self.val[which])
+
+    def children(self):
+        return self._iter(self.val)
+
+    def to_string(self):
+        return None
+
+
 # A "regular expression" printer which conforms to the
 # "SubPrettyPrinter" protocol from gdb.printing.
 class RxPrinter(object):
@@ -1629,6 +1662,7 @@
     libstdcxx_printer.add_container('std::', 'map', StdMapPrinter)
     libstdcxx_printer.add_container('std::', 'multimap', StdMapPrinter)
     libstdcxx_printer.add_container('std::', 'multiset', StdSetPrinter)
+    libstdcxx_printer.add_version('std::', 'pair', StdPairPrinter)
     libstdcxx_printer.add_version('std::', 'priority_queue',
                                   StdStackOrQueuePrinter)
     libstdcxx_printer.add_version('std::', 'queue', StdStackOrQueuePrinter)
diff -Naur gcc-8.2.0/libstdc++-v3/src/c++11/system_error.cc gcc-8-20181012/libstdc++-v3/src/c++11/system_error.cc
--- gcc-8.2.0/libstdc++-v3/src/c++11/system_error.cc	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/src/c++11/system_error.cc	2018-08-08 00:38:55.000000000 +0300
@@ -29,6 +29,7 @@
 #include <system_error>
 #include <bits/functexcept.h>
 #include <limits>
+#include <errno.h>
 #undef __sso_string
 
 namespace
@@ -65,6 +66,261 @@
       // _GLIBCXX_HAVE_STRERROR_L, strerror_l(i, cloc)
       return string(strerror(i));
     }
+
+    virtual std::error_condition
+    default_error_condition(int ev) const noexcept
+    {
+      switch (ev)
+      {
+      // List of errno macros from [cerrno.syn].
+      // C11 only defines EDOM, EILSEQ and ERANGE, the rest are from POSIX.
+      // They expand to integer constant expressions with type int,
+      // and distinct positive values, suitable for use in #if directives.
+      // POSIX adds more macros (but they're not defined on all targets,
+      // see config/os/*/error_constants.h), and POSIX allows
+      // EAGAIN == EWOULDBLOCK and ENOTSUP == EOPNOTSUPP.
+
+#ifdef E2BIG
+      case E2BIG:
+#endif
+#ifdef EACCES
+      case EACCES:
+#endif
+#ifdef EADDRINUSE
+      case EADDRINUSE:
+#endif
+#ifdef EADDRNOTAVAIL
+      case EADDRNOTAVAIL:
+#endif
+#ifdef EAFNOSUPPORT
+      case EAFNOSUPPORT:
+#endif
+#ifdef EAGAIN
+      case EAGAIN:
+#endif
+#ifdef EALREADY
+      case EALREADY:
+#endif
+#ifdef EBADF
+      case EBADF:
+#endif
+#ifdef EBADMSG
+      case EBADMSG:
+#endif
+#ifdef EBUSY
+      case EBUSY:
+#endif
+#ifdef ECANCELED
+      case ECANCELED:
+#endif
+#ifdef ECHILD
+      case ECHILD:
+#endif
+#ifdef ECONNABORTED
+      case ECONNABORTED:
+#endif
+#ifdef ECONNREFUSED
+      case ECONNREFUSED:
+#endif
+#ifdef ECONNRESET
+      case ECONNRESET:
+#endif
+#ifdef EDEADLK
+      case EDEADLK:
+#endif
+#ifdef EDESTADDRREQ
+      case EDESTADDRREQ:
+#endif
+      case EDOM:
+#ifdef EEXIST
+      case EEXIST:
+#endif
+#ifdef EFAULT
+      case EFAULT:
+#endif
+#ifdef EFBIG
+      case EFBIG:
+#endif
+#ifdef EHOSTUNREACH
+      case EHOSTUNREACH:
+#endif
+#ifdef EIDRM
+      case EIDRM:
+#endif
+      case EILSEQ:
+#ifdef EINPROGRESS
+      case EINPROGRESS:
+#endif
+#ifdef EINTR
+      case EINTR:
+#endif
+#ifdef EINVAL
+      case EINVAL:
+#endif
+#ifdef EIO
+      case EIO:
+#endif
+#ifdef EISCONN
+      case EISCONN:
+#endif
+#ifdef EISDIR
+      case EISDIR:
+#endif
+#ifdef ELOOP
+      case ELOOP:
+#endif
+#ifdef EMFILE
+      case EMFILE:
+#endif
+#ifdef EMLINK
+      case EMLINK:
+#endif
+#ifdef EMSGSIZE
+      case EMSGSIZE:
+#endif
+#ifdef ENAMETOOLONG
+      case ENAMETOOLONG:
+#endif
+#ifdef ENETDOWN
+      case ENETDOWN:
+#endif
+#ifdef ENETRESET
+      case ENETRESET:
+#endif
+#ifdef ENETUNREACH
+      case ENETUNREACH:
+#endif
+#ifdef ENFILE
+      case ENFILE:
+#endif
+#ifdef ENOBUFS
+      case ENOBUFS:
+#endif
+#ifdef ENODATA
+      case ENODATA:
+#endif
+#ifdef ENODEV
+      case ENODEV:
+#endif
+#ifdef ENOENT
+      case ENOENT:
+#endif
+#ifdef ENOEXEC
+      case ENOEXEC:
+#endif
+#ifdef ENOLCK
+      case ENOLCK:
+#endif
+#ifdef ENOLINK
+      case ENOLINK:
+#endif
+#ifdef ENOMEM
+      case ENOMEM:
+#endif
+#ifdef ENOMSG
+      case ENOMSG:
+#endif
+#ifdef ENOPROTOOPT
+      case ENOPROTOOPT:
+#endif
+#ifdef ENOSPC
+      case ENOSPC:
+#endif
+#ifdef ENOSR
+      case ENOSR:
+#endif
+#ifdef ENOSTR
+      case ENOSTR:
+#endif
+#ifdef ENOSYS
+      case ENOSYS:
+#endif
+#ifdef ENOTCONN
+      case ENOTCONN:
+#endif
+#ifdef ENOTDIR
+      case ENOTDIR:
+#endif
+#if defined ENOTEMPTY && (!defined EEXIST || ENOTEMPTY != EEXIST)
+      // AIX sometimes uses the same value for EEXIST and ENOTEMPTY
+      case ENOTEMPTY:
+#endif
+#ifdef ENOTRECOVERABLE
+      case ENOTRECOVERABLE:
+#endif
+#ifdef ENOTSOCK
+      case ENOTSOCK:
+#endif
+#ifdef ENOTSUP
+      case ENOTSUP:
+#endif
+#ifdef ENOTTY
+      case ENOTTY:
+#endif
+#ifdef ENXIO
+      case ENXIO:
+#endif
+#if defined EOPNOTSUPP && (!defined ENOTSUP || EOPNOTSUPP != ENOTSUP)
+      case EOPNOTSUPP:
+#endif
+#ifdef EOVERFLOW
+      case EOVERFLOW:
+#endif
+#ifdef EOWNERDEAD
+      case EOWNERDEAD:
+#endif
+#ifdef EPERM
+      case EPERM:
+#endif
+#ifdef EPIPE
+      case EPIPE:
+#endif
+#ifdef EPROTO
+      case EPROTO:
+#endif
+#ifdef EPROTONOSUPPORT
+      case EPROTONOSUPPORT:
+#endif
+#ifdef EPROTOTYPE
+      case EPROTOTYPE:
+#endif
+      case ERANGE:
+#ifdef EROFS
+      case EROFS:
+#endif
+#ifdef ESPIPE
+      case ESPIPE:
+#endif
+#ifdef ESRCH
+      case ESRCH:
+#endif
+#ifdef ETIME
+      case ETIME:
+#endif
+#ifdef ETIMEDOUT
+      case ETIMEDOUT:
+#endif
+#ifdef ETXTBSY
+      case ETXTBSY:
+#endif
+#if defined EWOULDBLOCK && (!defined EAGAIN || EWOULDBLOCK != EAGAIN)
+      case EWOULDBLOCK:
+#endif
+#ifdef EXDEV
+      case EXDEV:
+#endif
+        return std::error_condition(ev, std::generic_category());
+
+      /* Additional system-dependent mappings from non-standard error codes
+       * to one of the POSIX values above would go here, e.g.
+      case EBLAH:
+	return std::error_condition(EINVAL, std::generic_category());
+       */
+
+      default:
+	return std::error_condition(ev, std::system_category());
+      }
+    }
   };
 
   const generic_error_category generic_category_instance{};
diff -Naur gcc-8.2.0/libstdc++-v3/src/filesystem/std-path.cc gcc-8-20181012/libstdc++-v3/src/filesystem/std-path.cc
--- gcc-8.2.0/libstdc++-v3/src/filesystem/std-path.cc	2018-01-03 13:03:58.000000000 +0300
+++ gcc-8-20181012/libstdc++-v3/src/filesystem/std-path.cc	2018-08-28 18:52:18.000000000 +0300
@@ -378,7 +378,7 @@
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       // Replace each slash character in the root-name
-      if (p.is_root_name())
+      if (p._M_type == _Type::_Root_name || p._M_type == _Type::_Root_dir)
 	{
 	  string_type s = p.native();
 	  std::replace(s.begin(), s.end(), L'/', L'\\');
@@ -398,7 +398,8 @@
 	    }
 	  else if (!ret.has_relative_path())
 	    {
-	      if (!ret.is_absolute())
+	      // remove a dot-dot filename immediately after root-directory
+	      if (!ret.has_root_directory())
 		ret /= p;
 	    }
 	  else
@@ -411,8 +412,18 @@
 		{
 		  // Remove the filename before the trailing slash
 		  // (equiv. to ret = ret.parent_path().remove_filename())
-		  ret._M_pathname.erase(elem._M_cur->_M_pos);
-		  ret._M_cmpts.erase(elem._M_cur, ret._M_cmpts.end());
+
+		  if (elem == ret.begin())
+		    ret.clear();
+		  else
+		    {
+		      ret._M_pathname.erase(elem._M_cur->_M_pos);
+		      // Do we still have a trailing slash?
+		      if (std::prev(elem)->_M_type == _Type::_Filename)
+			ret._M_cmpts.erase(elem._M_cur);
+		      else
+			ret._M_cmpts.erase(elem._M_cur, ret._M_cmpts.end());
+		    }
 		}
 	      else // ???
 		ret /= p;
